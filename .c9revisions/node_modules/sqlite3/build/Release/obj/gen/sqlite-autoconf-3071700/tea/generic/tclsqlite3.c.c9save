{"ts":1378901700971,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#ifdef USE_SYSTEM_SQLITE\n# include <sqlite3.h>\n#else\n#include \"../../sqlite3.c\"\n#endif\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** A TCL Interface to SQLite.  Append this file to sqlite3.c and\n** compile the whole thing to build a TCL-enabled version of SQLite.\n**\n** Compile-time options:\n**\n**  -DTCLSH=1             Add a \"main()\" routine that works as a tclsh.\n**\n**  -DSQLITE_TCLMD5       When used in conjuction with -DTCLSH=1, add\n**                        four new commands to the TCL interpreter for\n**                        generating MD5 checksums:  md5, md5file,\n**                        md5-10x8, and md5file-10x8.\n**\n**  -DSQLITE_TEST         When used in conjuction with -DTCLSH=1, add\n**                        hundreds of new commands used for testing\n**                        SQLite.  This option implies -DSQLITE_TCLMD5.\n*/\n#include \"tcl.h\"\n#include <errno.h>\n\n/*\n** Some additional include files are needed if this file is not\n** appended to the amalgamation.\n*/\n#ifndef SQLITE_AMALGAMATION\n# include \"sqlite3.h\"\n# include <stdlib.h>\n# include <string.h>\n# include <assert.h>\n  typedef unsigned char u8;\n#endif\n#include <ctype.h>\n\n/*\n * Windows needs to know which symbols to export.  Unix does not.\n * BUILD_sqlite should be undefined for Unix.\n */\n#ifdef BUILD_sqlite\n#undef TCL_STORAGE_CLASS\n#define TCL_STORAGE_CLASS DLLEXPORT\n#endif /* BUILD_sqlite */\n\n#define NUM_PREPARED_STMTS 10\n#define MAX_PREPARED_STMTS 100\n\n/* Forward declaration */\ntypedef struct SqliteDb SqliteDb;\n\n/*\n** New SQL functions can be created as TCL scripts.  Each such function\n** is described by an instance of the following structure.\n*/\ntypedef struct SqlFunc SqlFunc;\nstruct SqlFunc {\n  Tcl_Interp *interp;   /* The TCL interpret to execute the function */\n  Tcl_Obj *pScript;     /* The Tcl_Obj representation of the script */\n  SqliteDb *pDb;        /* Database connection that owns this function */\n  int useEvalObjv;      /* True if it is safe to use Tcl_EvalObjv */\n  char *zName;          /* Name of this function */\n  SqlFunc *pNext;       /* Next function on the list of them all */\n};\n\n/*\n** New collation sequences function can be created as TCL scripts.  Each such\n** function is described by an instance of the following structure.\n*/\ntypedef struct SqlCollate SqlCollate;\nstruct SqlCollate {\n  Tcl_Interp *interp;   /* The TCL interpret to execute the function */\n  char *zScript;        /* The script to be run */\n  SqlCollate *pNext;    /* Next function on the list of them all */\n};\n\n/*\n** Prepared statements are cached for faster execution.  Each prepared\n** statement is described by an instance of the following structure.\n*/\ntypedef struct SqlPreparedStmt SqlPreparedStmt;\nstruct SqlPreparedStmt {\n  SqlPreparedStmt *pNext;  /* Next in linked list */\n  SqlPreparedStmt *pPrev;  /* Previous on the list */\n  sqlite3_stmt *pStmt;     /* The prepared statement */\n  int nSql;                /* chars in zSql[] */\n  const char *zSql;        /* Text of the SQL statement */\n  int nParm;               /* Size of apParm array */\n  Tcl_Obj **apParm;        /* Array of referenced object pointers */\n};\n\ntypedef struct IncrblobChannel IncrblobChannel;\n\n/*\n** There is one instance of this structure for each SQLite database\n** that has been opened by the SQLite TCL interface.\n**\n** If this module is built with SQLITE_TEST defined (to create the SQLite\n** testfixture executable), then it may be configured to use either\n** sqlite3_prepare_v2() or sqlite3_prepare() to prepare SQL statements.\n** If SqliteDb.bLegacyPrepare is true, sqlite3_prepare() is used.\n*/\nstruct SqliteDb {\n  sqlite3 *db;               /* The \"real\" database structure. MUST BE FIRST */\n  Tcl_Interp *interp;        /* The interpreter used for this database */\n  char *zBusy;               /* The busy callback routine */\n  char *zCommit;             /* The commit hook callback routine */\n  char *zTrace;              /* The trace callback routine */\n  char *zProfile;            /* The profile callback routine */\n  char *zProgress;           /* The progress callback routine */\n  char *zAuth;               /* The authorization callback routine */\n  int disableAuth;           /* Disable the authorizer if it exists */\n  char *zNull;               /* Text to substitute for an SQL NULL value */\n  SqlFunc *pFunc;            /* List of SQL functions */\n  Tcl_Obj *pUpdateHook;      /* Update hook script (if any) */\n  Tcl_Obj *pRollbackHook;    /* Rollback hook script (if any) */\n  Tcl_Obj *pWalHook;         /* WAL hook script (if any) */\n  Tcl_Obj *pUnlockNotify;    /* Unlock notify script (if any) */\n  SqlCollate *pCollate;      /* List of SQL collation functions */\n  int rc;                    /* Return code of most recent sqlite3_exec() */\n  Tcl_Obj *pCollateNeeded;   /* Collation needed script */\n  SqlPreparedStmt *stmtList; /* List of prepared statements*/\n  SqlPreparedStmt *stmtLast; /* Last statement in the list */\n  int maxStmt;               /* The next maximum number of stmtList */\n  int nStmt;                 /* Number of statements in stmtList */\n  IncrblobChannel *pIncrblob;/* Linked list of open incrblob channels */\n  int nStep, nSort, nIndex;  /* Statistics for most recent operation */\n  int nTransaction;          /* Number of nested [transaction] methods */\n#ifdef SQLITE_TEST\n  int bLegacyPrepare;        /* True to use sqlite3_prepare() */\n#endif\n};\n\nstruct IncrblobChannel {\n  sqlite3_blob *pBlob;      /* sqlite3 blob handle */\n  SqliteDb *pDb;            /* Associated database connection */\n  int iSeek;                /* Current seek offset */\n  Tcl_Channel channel;      /* Channel identifier */\n  IncrblobChannel *pNext;   /* Linked list of all open incrblob channels */\n  IncrblobChannel *pPrev;   /* Linked list of all open incrblob channels */\n};\n\n/*\n** Compute a string length that is limited to what can be stored in\n** lower 30 bits of a 32-bit signed integer.\n*/\nstatic int strlen30(const char *z){\n  const char *z2 = z;\n  while( *z2 ){ z2++; }\n  return 0x3fffffff & (int)(z2 - z);\n}\n\n\n#ifndef SQLITE_OMIT_INCRBLOB\n/*\n** Close all incrblob channels opened using database connection pDb.\n** This is called when shutting down the database connection.\n*/\nstatic void closeIncrblobChannels(SqliteDb *pDb){\n  IncrblobChannel *p;\n  IncrblobChannel *pNext;\n\n  for(p=pDb->pIncrblob; p; p=pNext){\n    pNext = p->pNext;\n\n    /* Note: Calling unregister here call Tcl_Close on the incrblob channel, \n    ** which deletes the IncrblobChannel structure at *p. So do not\n    ** call Tcl_Free() here.\n    */\n    Tcl_UnregisterChannel(pDb->interp, p->channel);\n  }\n}\n\n/*\n** Close an incremental blob channel.\n*/\nstatic int incrblobClose(ClientData instanceData, Tcl_Interp *interp){\n  IncrblobChannel *p = (IncrblobChannel *)instanceData;\n  int rc = sqlite3_blob_close(p->pBlob);\n  sqlite3 *db = p->pDb->db;\n\n  /* Remove the channel from the SqliteDb.pIncrblob list. */\n  if( p->pNext ){\n    p->pNext->pPrev = p->pPrev;\n  }\n  if( p->pPrev ){\n    p->pPrev->pNext = p->pNext;\n  }\n  if( p->pDb->pIncrblob==p ){\n    p->pDb->pIncrblob = p->pNext;\n  }\n\n  /* Free the IncrblobChannel structure */\n  Tcl_Free((char *)p);\n\n  if( rc!=SQLITE_OK ){\n    Tcl_SetResult(interp, (char *)sqlite3_errmsg(db), TCL_VOLATILE);\n    return TCL_ERROR;\n  }\n  return TCL_OK;\n}\n\n/*\n** Read data from an incremental blob channel.\n*/\nstatic int incrblobInput(\n  ClientData instanceData, \n  char *buf, \n  int bufSize,\n  int *errorCodePtr\n){\n  IncrblobChannel *p = (IncrblobChannel *)instanceData;\n  int nRead = bufSize;         /* Number of bytes to read */\n  int nBlob;                   /* Total size of the blob */\n  int rc;                      /* sqlite error code */\n\n  nBlob = sqlite3_blob_bytes(p->pBlob);\n  if( (p->iSeek+nRead)>nBlob ){\n    nRead = nBlob-p->iSeek;\n  }\n  if( nRead<=0 ){\n    return 0;\n  }\n\n  rc = sqlite3_blob_read(p->pBlob, (void *)buf, nRead, p->iSeek);\n  if( rc!=SQLITE_OK ){\n    *errorCodePtr = rc;\n    return -1;\n  }\n\n  p->iSeek += nRead;\n  return nRead;\n}\n\n/*\n** Write data to an incremental blob channel.\n*/\nstatic int incrblobOutput(\n  ClientData instanceData, \n  CONST char *buf, \n  int toWrite,\n  int *errorCodePtr\n){\n  IncrblobChannel *p = (IncrblobChannel *)instanceData;\n  int nWrite = toWrite;        /* Number of bytes to write */\n  int nBlob;                   /* Total size of the blob */\n  int rc;                      /* sqlite error code */\n\n  nBlob = sqlite3_blob_bytes(p->pBlob);\n  if( (p->iSeek+nWrite)>nBlob ){\n    *errorCodePtr = EINVAL;\n    return -1;\n  }\n  if( nWrite<=0 ){\n    return 0;\n  }\n\n  rc = sqlite3_blob_write(p->pBlob, (void *)buf, nWrite, p->iSeek);\n  if( rc!=SQLITE_OK ){\n    *errorCodePtr = EIO;\n    return -1;\n  }\n\n  p->iSeek += nWrite;\n  return nWrite;\n}\n\n/*\n** Seek an incremental blob channel.\n*/\nstatic int incrblobSeek(\n  ClientData instanceData, \n  long offset,\n  int seekMode,\n  int *errorCodePtr\n){\n  IncrblobChannel *p = (IncrblobChannel *)instanceData;\n\n  switch( seekMode ){\n    case SEEK_SET:\n      p->iSeek = offset;\n      break;\n    case SEEK_CUR:\n      p->iSeek += offset;\n      break;\n    case SEEK_END:\n      p->iSeek = sqlite3_blob_bytes(p->pBlob) + offset;\n      break;\n\n    default: assert(!\"Bad seekMode\");\n  }\n\n  return p->iSeek;\n}\n\n\nstatic void incrblobWatch(ClientData instanceData, int mode){ \n  /* NO-OP */ \n}\nstatic int incrblobHandle(ClientData instanceData, int dir, ClientData *hPtr){\n  return TCL_ERROR;\n}\n\nstatic Tcl_ChannelType IncrblobChannelType = {\n  \"incrblob\",                        /* typeName                             */\n  TCL_CHANNEL_VERSION_2,             /* version                              */\n  incrblobClose,                     /* closeProc                            */\n  incrblobInput,                     /* inputProc                            */\n  incrblobOutput,                    /* outputProc                           */\n  incrblobSeek,                      /* seekProc                             */\n  0,                                 /* setOptionProc                        */\n  0,                                 /* getOptionProc                        */\n  incrblobWatch,                     /* watchProc (this is a no-op)          */\n  incrblobHandle,                    /* getHandleProc (always returns error) */\n  0,                                 /* close2Proc                           */\n  0,                                 /* blockModeProc                        */\n  0,                                 /* flushProc                            */\n  0,                                 /* handlerProc                          */\n  0,                                 /* wideSeekProc                         */\n};\n\n/*\n** Create a new incrblob channel.\n*/\nstatic int createIncrblobChannel(\n  Tcl_Interp *interp, \n  SqliteDb *pDb, \n  const char *zDb,\n  const char *zTable, \n  const char *zColumn, \n  sqlite_int64 iRow,\n  int isReadonly\n){\n  IncrblobChannel *p;\n  sqlite3 *db = pDb->db;\n  sqlite3_blob *pBlob;\n  int rc;\n  int flags = TCL_READABLE|(isReadonly ? 0 : TCL_WRITABLE);\n\n  /* This variable is used to name the channels: \"incrblob_[incr count]\" */\n  static int count = 0;\n  char zChannel[64];\n\n  rc = sqlite3_blob_open(db, zDb, zTable, zColumn, iRow, !isReadonly, &pBlob);\n  if( rc!=SQLITE_OK ){\n    Tcl_SetResult(interp, (char *)sqlite3_errmsg(pDb->db), TCL_VOLATILE);\n    return TCL_ERROR;\n  }\n\n  p = (IncrblobChannel *)Tcl_Alloc(sizeof(IncrblobChannel));\n  p->iSeek = 0;\n  p->pBlob = pBlob;\n\n  sqlite3_snprintf(sizeof(zChannel), zChannel, \"incrblob_%d\", ++count);\n  p->channel = Tcl_CreateChannel(&IncrblobChannelType, zChannel, p, flags);\n  Tcl_RegisterChannel(interp, p->channel);\n\n  /* Link the new channel into the SqliteDb.pIncrblob list. */\n  p->pNext = pDb->pIncrblob;\n  p->pPrev = 0;\n  if( p->pNext ){\n    p->pNext->pPrev = p;\n  }\n  pDb->pIncrblob = p;\n  p->pDb = pDb;\n\n  Tcl_SetResult(interp, (char *)Tcl_GetChannelName(p->channel), TCL_VOLATILE);\n  return TCL_OK;\n}\n#else  /* else clause for \"#ifndef SQLITE_OMIT_INCRBLOB\" */\n  #define closeIncrblobChannels(pDb)\n#endif\n\n/*\n** Look at the script prefix in pCmd.  We will be executing this script\n** after first appending one or more arguments.  This routine analyzes\n** the script to see if it is safe to use Tcl_EvalObjv() on the script\n** rather than the more general Tcl_EvalEx().  Tcl_EvalObjv() is much\n** faster.\n**\n** Scripts that are safe to use with Tcl_EvalObjv() consists of a\n** command name followed by zero or more arguments with no [...] or $\n** or {...} or ; to be seen anywhere.  Most callback scripts consist\n** of just a single procedure name and they meet this requirement.\n*/\nstatic int safeToUseEvalObjv(Tcl_Interp *interp, Tcl_Obj *pCmd){\n  /* We could try to do something with Tcl_Parse().  But we will instead\n  ** just do a search for forbidden characters.  If any of the forbidden\n  ** characters appear in pCmd, we will report the string as unsafe.\n  */\n  const char *z;\n  int n;\n  z = Tcl_GetStringFromObj(pCmd, &n);\n  while( n-- > 0 ){\n    int c = *(z++);\n    if( c=='$' || c=='[' || c==';' ) return 0;\n  }\n  return 1;\n}\n\n/*\n** Find an SqlFunc structure with the given name.  Or create a new\n** one if an existing one cannot be found.  Return a pointer to the\n** structure.\n*/\nstatic SqlFunc *findSqlFunc(SqliteDb *pDb, const char *zName){\n  SqlFunc *p, *pNew;\n  int i;\n  pNew = (SqlFunc*)Tcl_Alloc( sizeof(*pNew) + strlen30(zName) + 1 );\n  pNew->zName = (char*)&pNew[1];\n  for(i=0; zName[i]; i++){ pNew->zName[i] = tolower(zName[i]); }\n  pNew->zName[i] = 0;\n  for(p=pDb->pFunc; p; p=p->pNext){ \n    if( strcmp(p->zName, pNew->zName)==0 ){\n      Tcl_Free((char*)pNew);\n      return p;\n    }\n  }\n  pNew->interp = pDb->interp;\n  pNew->pDb = pDb;\n  pNew->pScript = 0;\n  pNew->pNext = pDb->pFunc;\n  pDb->pFunc = pNew;\n  return pNew;\n}\n\n/*\n** Free a single SqlPreparedStmt object.\n*/\nstatic void dbFreeStmt(SqlPreparedStmt *pStmt){\n#ifdef SQLITE_TEST\n  if( sqlite3_sql(pStmt->pStmt)==0 ){\n    Tcl_Free((char *)pStmt->zSql);\n  }\n#endif\n  sqlite3_finalize(pStmt->pStmt);\n  Tcl_Free((char *)pStmt);\n}\n\n/*\n** Finalize and free a list of prepared statements\n*/\nstatic void flushStmtCache(SqliteDb *pDb){\n  SqlPreparedStmt *pPreStmt;\n  SqlPreparedStmt *pNext;\n\n  for(pPreStmt = pDb->stmtList; pPreStmt; pPreStmt=pNext){\n    pNext = pPreStmt->pNext;\n    dbFreeStmt(pPreStmt);\n  }\n  pDb->nStmt = 0;\n  pDb->stmtLast = 0;\n  pDb->stmtList = 0;\n}\n\n/*\n** TCL calls this procedure when an sqlite3 database command is\n** deleted.\n*/\nstatic void DbDeleteCmd(void *db){\n  SqliteDb *pDb = (SqliteDb*)db;\n  flushStmtCache(pDb);\n  closeIncrblobChannels(pDb);\n  sqlite3_close(pDb->db);\n  while( pDb->pFunc ){\n    SqlFunc *pFunc = pDb->pFunc;\n    pDb->pFunc = pFunc->pNext;\n    assert( pFunc->pDb==pDb );\n    Tcl_DecrRefCount(pFunc->pScript);\n    Tcl_Free((char*)pFunc);\n  }\n  while( pDb->pCollate ){\n    SqlCollate *pCollate = pDb->pCollate;\n    pDb->pCollate = pCollate->pNext;\n    Tcl_Free((char*)pCollate);\n  }\n  if( pDb->zBusy ){\n    Tcl_Free(pDb->zBusy);\n  }\n  if( pDb->zTrace ){\n    Tcl_Free(pDb->zTrace);\n  }\n  if( pDb->zProfile ){\n    Tcl_Free(pDb->zProfile);\n  }\n  if( pDb->zAuth ){\n    Tcl_Free(pDb->zAuth);\n  }\n  if( pDb->zNull ){\n    Tcl_Free(pDb->zNull);\n  }\n  if( pDb->pUpdateHook ){\n    Tcl_DecrRefCount(pDb->pUpdateHook);\n  }\n  if( pDb->pRollbackHook ){\n    Tcl_DecrRefCount(pDb->pRollbackHook);\n  }\n  if( pDb->pWalHook ){\n    Tcl_DecrRefCount(pDb->pWalHook);\n  }\n  if( pDb->pCollateNeeded ){\n    Tcl_DecrRefCount(pDb->pCollateNeeded);\n  }\n  Tcl_Free((char*)pDb);\n}\n\n/*\n** This routine is called when a database file is locked while trying\n** to execute SQL.\n*/\nstatic int DbBusyHandler(void *cd, int nTries){\n  SqliteDb *pDb = (SqliteDb*)cd;\n  int rc;\n  char zVal[30];\n\n  sqlite3_snprintf(sizeof(zVal), zVal, \"%d\", nTries);\n  rc = Tcl_VarEval(pDb->interp, pDb->zBusy, \" \", zVal, (char*)0);\n  if( rc!=TCL_OK || atoi(Tcl_GetStringResult(pDb->interp)) ){\n    return 0;\n  }\n  return 1;\n}\n\n#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n/*\n** This routine is invoked as the 'progress callback' for the database.\n*/\nstatic int DbProgressHandler(void *cd){\n  SqliteDb *pDb = (SqliteDb*)cd;\n  int rc;\n\n  assert( pDb->zProgress );\n  rc = Tcl_Eval(pDb->interp, pDb->zProgress);\n  if( rc!=TCL_OK || atoi(Tcl_GetStringResult(pDb->interp)) ){\n    return 1;\n  }\n  return 0;\n}\n#endif\n\n#ifndef SQLITE_OMIT_TRACE\n/*\n** This routine is called by the SQLite trace handler whenever a new\n** block of SQL is executed.  The TCL script in pDb->zTrace is executed.\n*/\nstatic void DbTraceHandler(void *cd, const char *zSql){\n  SqliteDb *pDb = (SqliteDb*)cd;\n  Tcl_DString str;\n\n  Tcl_DStringInit(&str);\n  Tcl_DStringAppend(&str, pDb->zTrace, -1);\n  Tcl_DStringAppendElement(&str, zSql);\n  Tcl_Eval(pDb->interp, Tcl_DStringValue(&str));\n  Tcl_DStringFree(&str);\n  Tcl_ResetResult(pDb->interp);\n}\n#endif\n\n#ifndef SQLITE_OMIT_TRACE\n/*\n** This routine is called by the SQLite profile handler after a statement\n** SQL has executed.  The TCL script in pDb->zProfile is evaluated.\n*/\nstatic void DbProfileHandler(void *cd, const char *zSql, sqlite_uint64 tm){\n  SqliteDb *pDb = (SqliteDb*)cd;\n  Tcl_DString str;\n  char zTm[100];\n\n  sqlite3_snprintf(sizeof(zTm)-1, zTm, \"%lld\", tm);\n  Tcl_DStringInit(&str);\n  Tcl_DStringAppend(&str, pDb->zProfile, -1);\n  Tcl_DStringAppendElement(&str, zSql);\n  Tcl_DStringAppendElement(&str, zTm);\n  Tcl_Eval(pDb->interp, Tcl_DStringValue(&str));\n  Tcl_DStringFree(&str);\n  Tcl_ResetResult(pDb->interp);\n}\n#endif\n\n/*\n** This routine is called when a transaction is committed.  The\n** TCL script in pDb->zCommit is executed.  If it returns non-zero or\n** if it throws an exception, the transaction is rolled back instead\n** of being committed.\n*/\nstatic int DbCommitHandler(void *cd){\n  SqliteDb *pDb = (SqliteDb*)cd;\n  int rc;\n\n  rc = Tcl_Eval(pDb->interp, pDb->zCommit);\n  if( rc!=TCL_OK || atoi(Tcl_GetStringResult(pDb->interp)) ){\n    return 1;\n  }\n  return 0;\n}\n\nstatic void DbRollbackHandler(void *clientData){\n  SqliteDb *pDb = (SqliteDb*)clientData;\n  assert(pDb->pRollbackHook);\n  if( TCL_OK!=Tcl_EvalObjEx(pDb->interp, pDb->pRollbackHook, 0) ){\n    Tcl_BackgroundError(pDb->interp);\n  }\n}\n\n/*\n** This procedure handles wal_hook callbacks.\n*/\nstatic int DbWalHandler(\n  void *clientData, \n  sqlite3 *db, \n  const char *zDb, \n  int nEntry\n){\n  int ret = SQLITE_OK;\n  Tcl_Obj *p;\n  SqliteDb *pDb = (SqliteDb*)clientData;\n  Tcl_Interp *interp = pDb->interp;\n  assert(pDb->pWalHook);\n\n  p = Tcl_DuplicateObj(pDb->pWalHook);\n  Tcl_IncrRefCount(p);\n  Tcl_ListObjAppendElement(interp, p, Tcl_NewStringObj(zDb, -1));\n  Tcl_ListObjAppendElement(interp, p, Tcl_NewIntObj(nEntry));\n  if( TCL_OK!=Tcl_EvalObjEx(interp, p, 0) \n   || TCL_OK!=Tcl_GetIntFromObj(interp, Tcl_GetObjResult(interp), &ret)\n  ){\n    Tcl_BackgroundError(interp);\n  }\n  Tcl_DecrRefCount(p);\n\n  return ret;\n}\n\n#if defined(SQLITE_TEST) && defined(SQLITE_ENABLE_UNLOCK_NOTIFY)\nstatic void setTestUnlockNotifyVars(Tcl_Interp *interp, int iArg, int nArg){\n  char zBuf[64];\n  sprintf(zBuf, \"%d\", iArg);\n  Tcl_SetVar(interp, \"sqlite_unlock_notify_arg\", zBuf, TCL_GLOBAL_ONLY);\n  sprintf(zBuf, \"%d\", nArg);\n  Tcl_SetVar(interp, \"sqlite_unlock_notify_argcount\", zBuf, TCL_GLOBAL_ONLY);\n}\n#else\n# define setTestUnlockNotifyVars(x,y,z)\n#endif\n\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\nstatic void DbUnlockNotify(void **apArg, int nArg){\n  int i;\n  for(i=0; i<nArg; i++){\n    const int flags = (TCL_EVAL_GLOBAL|TCL_EVAL_DIRECT);\n    SqliteDb *pDb = (SqliteDb *)apArg[i];\n    setTestUnlockNotifyVars(pDb->interp, i, nArg);\n    assert( pDb->pUnlockNotify);\n    Tcl_EvalObjEx(pDb->interp, pDb->pUnlockNotify, flags);\n    Tcl_DecrRefCount(pDb->pUnlockNotify);\n    pDb->pUnlockNotify = 0;\n  }\n}\n#endif\n\nstatic void DbUpdateHandler(\n  void *p, \n  int op,\n  const char *zDb, \n  const char *zTbl, \n  sqlite_int64 rowid\n){\n  SqliteDb *pDb = (SqliteDb *)p;\n  Tcl_Obj *pCmd;\n\n  assert( pDb->pUpdateHook );\n  assert( op==SQLITE_INSERT || op==SQLITE_UPDATE || op==SQLITE_DELETE );\n\n  pCmd = Tcl_DuplicateObj(pDb->pUpdateHook);\n  Tcl_IncrRefCount(pCmd);\n  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewStringObj(\n    ( (op==SQLITE_INSERT)?\"INSERT\":(op==SQLITE_UPDATE)?\"UPDATE\":\"DELETE\"), -1));\n  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewStringObj(zDb, -1));\n  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewStringObj(zTbl, -1));\n  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewWideIntObj(rowid));\n  Tcl_EvalObjEx(pDb->interp, pCmd, TCL_EVAL_DIRECT);\n  Tcl_DecrRefCount(pCmd);\n}\n\nstatic void tclCollateNeeded(\n  void *pCtx,\n  sqlite3 *db,\n  int enc,\n  const char *zName\n){\n  SqliteDb *pDb = (SqliteDb *)pCtx;\n  Tcl_Obj *pScript = Tcl_DuplicateObj(pDb->pCollateNeeded);\n  Tcl_IncrRefCount(pScript);\n  Tcl_ListObjAppendElement(0, pScript, Tcl_NewStringObj(zName, -1));\n  Tcl_EvalObjEx(pDb->interp, pScript, 0);\n  Tcl_DecrRefCount(pScript);\n}\n\n/*\n** This routine is called to evaluate an SQL collation function implemented\n** using TCL script.\n*/\nstatic int tclSqlCollate(\n  void *pCtx,\n  int nA,\n  const void *zA,\n  int nB,\n  const void *zB\n){\n  SqlCollate *p = (SqlCollate *)pCtx;\n  Tcl_Obj *pCmd;\n\n  pCmd = Tcl_NewStringObj(p->zScript, -1);\n  Tcl_IncrRefCount(pCmd);\n  Tcl_ListObjAppendElement(p->interp, pCmd, Tcl_NewStringObj(zA, nA));\n  Tcl_ListObjAppendElement(p->interp, pCmd, Tcl_NewStringObj(zB, nB));\n  Tcl_EvalObjEx(p->interp, pCmd, TCL_EVAL_DIRECT);\n  Tcl_DecrRefCount(pCmd);\n  return (atoi(Tcl_GetStringResult(p->interp)));\n}\n\n/*\n** This routine is called to evaluate an SQL function implemented\n** using TCL script.\n*/\nstatic void tclSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv){\n  SqlFunc *p = sqlite3_user_data(context);\n  Tcl_Obj *pCmd;\n  int i;\n  int rc;\n\n  if( argc==0 ){\n    /* If there are no arguments to the function, call Tcl_EvalObjEx on the\n    ** script object directly.  This allows the TCL compiler to generate\n    ** bytecode for the command on the first invocation and thus make\n    ** subsequent invocations much faster. */\n    pCmd = p->pScript;\n    Tcl_IncrRefCount(pCmd);\n    rc = Tcl_EvalObjEx(p->interp, pCmd, 0);\n    Tcl_DecrRefCount(pCmd);\n  }else{\n    /* If there are arguments to the function, make a shallow copy of the\n    ** script object, lappend the arguments, then evaluate the copy.\n    **\n    ** By \"shallow\" copy, we mean a only the outer list Tcl_Obj is duplicated.\n    ** The new Tcl_Obj contains pointers to the original list elements. \n    ** That way, when Tcl_EvalObjv() is run and shimmers the first element\n    ** of the list to tclCmdNameType, that alternate representation will\n    ** be preserved and reused on the next invocation.\n    */\n    Tcl_Obj **aArg;\n    int nArg;\n    if( Tcl_ListObjGetElements(p->interp, p->pScript, &nArg, &aArg) ){\n      sqlite3_result_error(context, Tcl_GetStringResult(p->interp), -1); \n      return;\n    }     \n    pCmd = Tcl_NewListObj(nArg, aArg);\n    Tcl_IncrRefCount(pCmd);\n    for(i=0; i<argc; i++){\n      sqlite3_value *pIn = argv[i];\n      Tcl_Obj *pVal;\n            \n      /* Set pVal to contain the i'th column of this row. */\n      switch( sqlite3_value_type(pIn) ){\n        case SQLITE_BLOB: {\n          int bytes = sqlite3_value_bytes(pIn);\n          pVal = Tcl_NewByteArrayObj(sqlite3_value_blob(pIn), bytes);\n          break;\n        }\n        case SQLITE_INTEGER: {\n          sqlite_int64 v = sqlite3_value_int64(pIn);\n          if( v>=-2147483647 && v<=2147483647 ){\n            pVal = Tcl_NewIntObj((int)v);\n          }else{\n            pVal = Tcl_NewWideIntObj(v);\n          }\n          break;\n        }\n        case SQLITE_FLOAT: {\n          double r = sqlite3_value_double(pIn);\n          pVal = Tcl_NewDoubleObj(r);\n          break;\n        }\n        case SQLITE_NULL: {\n          pVal = Tcl_NewStringObj(p->pDb->zNull, -1);\n          break;\n        }\n        default: {\n          int bytes = sqlite3_value_bytes(pIn);\n          pVal = Tcl_NewStringObj((char *)sqlite3_value_text(pIn), bytes);\n          break;\n        }\n      }\n      rc = Tcl_ListObjAppendElement(p->interp, pCmd, pVal);\n      if( rc ){\n        Tcl_DecrRefCount(pCmd);\n        sqlite3_result_error(context, Tcl_GetStringResult(p->interp), -1); \n        return;\n      }\n    }\n    if( !p->useEvalObjv ){\n      /* Tcl_EvalObjEx() will automatically call Tcl_EvalObjv() if pCmd\n      ** is a list without a string representation.  To prevent this from\n      ** happening, make sure pCmd has a valid string representation */\n      Tcl_GetString(pCmd);\n    }\n    rc = Tcl_EvalObjEx(p->interp, pCmd, TCL_EVAL_DIRECT);\n    Tcl_DecrRefCount(pCmd);\n  }\n\n  if( rc && rc!=TCL_RETURN ){\n    sqlite3_result_error(context, Tcl_GetStringResult(p->interp), -1); \n  }else{\n    Tcl_Obj *pVar = Tcl_GetObjResult(p->interp);\n    int n;\n    u8 *data;\n    const char *zType = (pVar->typePtr ? pVar->typePtr->name : \"\");\n    char c = zType[0];\n    if( c=='b' && strcmp(zType,\"bytearray\")==0 && pVar->bytes==0 ){\n      /* Only return a BLOB type if the Tcl variable is a bytearray and\n      ** has no string representation. */\n      data = Tcl_GetByteArrayFromObj(pVar, &n);\n      sqlite3_result_blob(context, data, n, SQLITE_TRANSIENT);\n    }else if( c=='b' && strcmp(zType,\"boolean\")==0 ){\n      Tcl_GetIntFromObj(0, pVar, &n);\n      sqlite3_result_int(context, n);\n    }else if( c=='d' && strcmp(zType,\"double\")==0 ){\n      double r;\n      Tcl_GetDoubleFromObj(0, pVar, &r);\n      sqlite3_result_double(context, r);\n    }else if( (c=='w' && strcmp(zType,\"wideInt\")==0) ||\n          (c=='i' && strcmp(zType,\"int\")==0) ){\n      Tcl_WideInt v;\n      Tcl_GetWideIntFromObj(0, pVar, &v);\n      sqlite3_result_int64(context, v);\n    }else{\n      data = (unsigned char *)Tcl_GetStringFromObj(pVar, &n);\n      sqlite3_result_text(context, (char *)data, n, SQLITE_TRANSIENT);\n    }\n  }\n}\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n/*\n** This is the authentication function.  It appends the authentication\n** type code and the two arguments to zCmd[] then invokes the result\n** on the interpreter.  The reply is examined to determine if the\n** authentication fails or succeeds.\n*/\nstatic int auth_callback(\n  void *pArg,\n  int code,\n  const char *zArg1,\n  const char *zArg2,\n  const char *zArg3,\n  const char *zArg4\n){\n  char *zCode;\n  Tcl_DString str;\n  int rc;\n  const char *zReply;\n  SqliteDb *pDb = (SqliteDb*)pArg;\n  if( pDb->disableAuth ) return SQLITE_OK;\n\n  switch( code ){\n    case SQLITE_COPY              : zCode=\"SQLITE_COPY\"; break;\n    case SQLITE_CREATE_INDEX      : zCode=\"SQLITE_CREATE_INDEX\"; break;\n    case SQLITE_CREATE_TABLE      : zCode=\"SQLITE_CREATE_TABLE\"; break;\n    case SQLITE_CREATE_TEMP_INDEX : zCode=\"SQLITE_CREATE_TEMP_INDEX\"; break;\n    case SQLITE_CREATE_TEMP_TABLE : zCode=\"SQLITE_CREATE_TEMP_TABLE\"; break;\n    case SQLITE_CREATE_TEMP_TRIGGER: zCode=\"SQLITE_CREATE_TEMP_TRIGGER\"; break;\n    case SQLITE_CREATE_TEMP_VIEW  : zCode=\"SQLITE_CREATE_TEMP_VIEW\"; break;\n    case SQLITE_CREATE_TRIGGER    : zCode=\"SQLITE_CREATE_TRIGGER\"; break;\n    case SQLITE_CREATE_VIEW       : zCode=\"SQLITE_CREATE_VIEW\"; break;\n    case SQLITE_DELETE            : zCode=\"SQLITE_DELETE\"; break;\n    case SQLITE_DROP_INDEX        : zCode=\"SQLITE_DROP_INDEX\"; break;\n    case SQLITE_DROP_TABLE        : zCode=\"SQLITE_DROP_TABLE\"; break;\n    case SQLITE_DROP_TEMP_INDEX   : zCode=\"SQLITE_DROP_TEMP_INDEX\"; break;\n    case SQLITE_DROP_TEMP_TABLE   : zCode=\"SQLITE_DROP_TEMP_TABLE\"; break;\n    case SQLITE_DROP_TEMP_TRIGGER : zCode=\"SQLITE_DROP_TEMP_TRIGGER\"; break;\n    case SQLITE_DROP_TEMP_VIEW    : zCode=\"SQLITE_DROP_TEMP_VIEW\"; break;\n    case SQLITE_DROP_TRIGGER      : zCode=\"SQLITE_DROP_TRIGGER\"; break;\n    case SQLITE_DROP_VIEW         : zCode=\"SQLITE_DROP_VIEW\"; break;\n    case SQLITE_INSERT            : zCode=\"SQLITE_INSERT\"; break;\n    case SQLITE_PRAGMA            : zCode=\"SQLITE_PRAGMA\"; break;\n    case SQLITE_READ              : zCode=\"SQLITE_READ\"; break;\n    case SQLITE_SELECT            : zCode=\"SQLITE_SELECT\"; break;\n    case SQLITE_TRANSACTION       : zCode=\"SQLITE_TRANSACTION\"; break;\n    case SQLITE_UPDATE            : zCode=\"SQLITE_UPDATE\"; break;\n    case SQLITE_ATTACH            : zCode=\"SQLITE_ATTACH\"; break;\n    case SQLITE_DETACH            : zCode=\"SQLITE_DETACH\"; break;\n    case SQLITE_ALTER_TABLE       : zCode=\"SQLITE_ALTER_TABLE\"; break;\n    case SQLITE_REINDEX           : zCode=\"SQLITE_REINDEX\"; break;\n    case SQLITE_ANALYZE           : zCode=\"SQLITE_ANALYZE\"; break;\n    case SQLITE_CREATE_VTABLE     : zCode=\"SQLITE_CREATE_VTABLE\"; break;\n    case SQLITE_DROP_VTABLE       : zCode=\"SQLITE_DROP_VTABLE\"; break;\n    case SQLITE_FUNCTION          : zCode=\"SQLITE_FUNCTION\"; break;\n    case SQLITE_SAVEPOINT         : zCode=\"SQLITE_SAVEPOINT\"; break;\n    default                       : zCode=\"????\"; break;\n  }\n  Tcl_DStringInit(&str);\n  Tcl_DStringAppend(&str, pDb->zAuth, -1);\n  Tcl_DStringAppendElement(&str, zCode);\n  Tcl_DStringAppendElement(&str, zArg1 ? zArg1 : \"\");\n  Tcl_DStringAppendElement(&str, zArg2 ? zArg2 : \"\");\n  Tcl_DStringAppendElement(&str, zArg3 ? zArg3 : \"\");\n  Tcl_DStringAppendElement(&str, zArg4 ? zArg4 : \"\");\n  rc = Tcl_GlobalEval(pDb->interp, Tcl_DStringValue(&str));\n  Tcl_DStringFree(&str);\n  zReply = rc==TCL_OK ? Tcl_GetStringResult(pDb->interp) : \"SQLITE_DENY\";\n  if( strcmp(zReply,\"SQLITE_OK\")==0 ){\n    rc = SQLITE_OK;\n  }else if( strcmp(zReply,\"SQLITE_DENY\")==0 ){\n    rc = SQLITE_DENY;\n  }else if( strcmp(zReply,\"SQLITE_IGNORE\")==0 ){\n    rc = SQLITE_IGNORE;\n  }else{\n    rc = 999;\n  }\n  return rc;\n}\n#endif /* SQLITE_OMIT_AUTHORIZATION */\n\n/*\n** This routine reads a line of text from FILE in, stores\n** the text in memory obtained from malloc() and returns a pointer\n** to the text.  NULL is returned at end of file, or if malloc()\n** fails.\n**\n** The interface is like \"readline\" but no command-line editing\n** is done.\n**\n** copied from shell.c from '.import' command\n*/\nstatic char *local_getline(char *zPrompt, FILE *in){\n  char *zLine;\n  int nLine;\n  int n;\n\n  nLine = 100;\n  zLine = malloc( nLine );\n  if( zLine==0 ) return 0;\n  n = 0;\n  while( 1 ){\n    if( n+100>nLine ){\n      nLine = nLine*2 + 100;\n      zLine = realloc(zLine, nLine);\n      if( zLine==0 ) return 0;\n    }\n    if( fgets(&zLine[n], nLine - n, in)==0 ){\n      if( n==0 ){\n        free(zLine);\n        return 0;\n      }\n      zLine[n] = 0;\n      break;\n    }\n    while( zLine[n] ){ n++; }\n    if( n>0 && zLine[n-1]=='\\n' ){\n      n--;\n      zLine[n] = 0;\n      break;\n    }\n  }\n  zLine = realloc( zLine, n+1 );\n  return zLine;\n}\n\n\n/*\n** This function is part of the implementation of the command:\n**\n**   $db transaction [-deferred|-immediate|-exclusive] SCRIPT\n**\n** It is invoked after evaluating the script SCRIPT to commit or rollback\n** the transaction or savepoint opened by the [transaction] command.\n*/\nstatic int DbTransPostCmd(\n  ClientData data[],                   /* data[0] is the Sqlite3Db* for $db */\n  Tcl_Interp *interp,                  /* Tcl interpreter */\n  int result                           /* Result of evaluating SCRIPT */\n){\n  static const char *azEnd[] = {\n    \"RELEASE _tcl_transaction\",        /* rc==TCL_ERROR, nTransaction!=0 */\n    \"COMMIT\",                          /* rc!=TCL_ERROR, nTransaction==0 */\n    \"ROLLBACK TO _tcl_transaction ; RELEASE _tcl_transaction\",\n    \"ROLLBACK\"                         /* rc==TCL_ERROR, nTransaction==0 */\n  };\n  SqliteDb *pDb = (SqliteDb*)data[0];\n  int rc = result;\n  const char *zEnd;\n\n  pDb->nTransaction--;\n  zEnd = azEnd[(rc==TCL_ERROR)*2 + (pDb->nTransaction==0)];\n\n  pDb->disableAuth++;\n  if( sqlite3_exec(pDb->db, zEnd, 0, 0, 0) ){\n      /* This is a tricky scenario to handle. The most likely cause of an\n      ** error is that the exec() above was an attempt to commit the \n      ** top-level transaction that returned SQLITE_BUSY. Or, less likely,\n      ** that an IO-error has occurred. In either case, throw a Tcl exception\n      ** and try to rollback the transaction.\n      **\n      ** But it could also be that the user executed one or more BEGIN, \n      ** COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing\n      ** this method's logic. Not clear how this would be best handled.\n      */\n    if( rc!=TCL_ERROR ){\n      Tcl_AppendResult(interp, sqlite3_errmsg(pDb->db), 0);\n      rc = TCL_ERROR;\n    }\n    sqlite3_exec(pDb->db, \"ROLLBACK\", 0, 0, 0);\n  }\n  pDb->disableAuth--;\n\n  return rc;\n}\n\n/*\n** Unless SQLITE_TEST is defined, this function is a simple wrapper around\n** sqlite3_prepare_v2(). If SQLITE_TEST is defined, then it uses either\n** sqlite3_prepare_v2() or legacy interface sqlite3_prepare(), depending\n** on whether or not the [db_use_legacy_prepare] command has been used to \n** configure the connection.\n*/\nstatic int dbPrepare(\n  SqliteDb *pDb,                  /* Database object */\n  const char *zSql,               /* SQL to compile */\n  sqlite3_stmt **ppStmt,          /* OUT: Prepared statement */\n  const char **pzOut              /* OUT: Pointer to next SQL statement */\n){\n#ifdef SQLITE_TEST\n  if( pDb->bLegacyPrepare ){\n    return sqlite3_prepare(pDb->db, zSql, -1, ppStmt, pzOut);\n  }\n#endif\n  return sqlite3_prepare_v2(pDb->db, zSql, -1, ppStmt, pzOut);\n}\n\n/*\n** Search the cache for a prepared-statement object that implements the\n** first SQL statement in the buffer pointed to by parameter zIn. If\n** no such prepared-statement can be found, allocate and prepare a new\n** one. In either case, bind the current values of the relevant Tcl\n** variables to any $var, :var or @var variables in the statement. Before\n** returning, set *ppPreStmt to point to the prepared-statement object.\n**\n** Output parameter *pzOut is set to point to the next SQL statement in\n** buffer zIn, or to the '\\0' byte at the end of zIn if there is no\n** next statement.\n**\n** If successful, TCL_OK is returned. Otherwise, TCL_ERROR is returned\n** and an error message loaded into interpreter pDb->interp.\n*/\nstatic int dbPrepareAndBind(\n  SqliteDb *pDb,                  /* Database object */\n  char const *zIn,                /* SQL to compile */\n  char const **pzOut,             /* OUT: Pointer to next SQL statement */\n  SqlPreparedStmt **ppPreStmt     /* OUT: Object used to cache statement */\n){\n  const char *zSql = zIn;         /* Pointer to first SQL statement in zIn */\n  sqlite3_stmt *pStmt;            /* Prepared statement object */\n  SqlPreparedStmt *pPreStmt;      /* Pointer to cached statement */\n  int nSql;                       /* Length of zSql in bytes */\n  int nVar;                       /* Number of variables in statement */\n  int iParm = 0;                  /* Next free entry in apParm */\n  int i;\n  Tcl_Interp *interp = pDb->interp;\n\n  *ppPreStmt = 0;\n\n  /* Trim spaces from the start of zSql and calculate the remaining length. */\n  while( isspace(zSql[0]) ){ zSql++; }\n  nSql = strlen30(zSql);\n\n  for(pPreStmt = pDb->stmtList; pPreStmt; pPreStmt=pPreStmt->pNext){\n    int n = pPreStmt->nSql;\n    if( nSql>=n \n        && memcmp(pPreStmt->zSql, zSql, n)==0\n        && (zSql[n]==0 || zSql[n-1]==';')\n    ){\n      pStmt = pPreStmt->pStmt;\n      *pzOut = &zSql[pPreStmt->nSql];\n\n      /* When a prepared statement is found, unlink it from the\n      ** cache list.  It will later be added back to the beginning\n      ** of the cache list in order to implement LRU replacement.\n      */\n      if( pPreStmt->pPrev ){\n        pPreStmt->pPrev->pNext = pPreStmt->pNext;\n      }else{\n        pDb->stmtList = pPreStmt->pNext;\n      }\n      if( pPreStmt->pNext ){\n        pPreStmt->pNext->pPrev = pPreStmt->pPrev;\n      }else{\n        pDb->stmtLast = pPreStmt->pPrev;\n      }\n      pDb->nStmt--;\n      nVar = sqlite3_bind_parameter_count(pStmt);\n      break;\n    }\n  }\n  \n  /* If no prepared statement was found. Compile the SQL text. Also allocate\n  ** a new SqlPreparedStmt structure.  */\n  if( pPreStmt==0 ){\n    int nByte;\n\n    if( SQLITE_OK!=dbPrepare(pDb, zSql, &pStmt, pzOut) ){\n      Tcl_SetObjResult(interp, Tcl_NewStringObj(sqlite3_errmsg(pDb->db), -1));\n      return TCL_ERROR;\n    }\n    if( pStmt==0 ){\n      if( SQLITE_OK!=sqlite3_errcode(pDb->db) ){\n        /* A compile-time error in the statement. */\n        Tcl_SetObjResult(interp, Tcl_NewStringObj(sqlite3_errmsg(pDb->db), -1));\n        return TCL_ERROR;\n      }else{\n        /* The statement was a no-op.  Continue to the next statement\n        ** in the SQL string.\n        */\n        return TCL_OK;\n      }\n    }\n\n    assert( pPreStmt==0 );\n    nVar = sqlite3_bind_parameter_count(pStmt);\n    nByte = sizeof(SqlPreparedStmt) + nVar*sizeof(Tcl_Obj *);\n    pPreStmt = (SqlPreparedStmt*)Tcl_Alloc(nByte);\n    memset(pPreStmt, 0, nByte);\n\n    pPreStmt->pStmt = pStmt;\n    pPreStmt->nSql = (int)(*pzOut - zSql);\n    pPreStmt->zSql = sqlite3_sql(pStmt);\n    pPreStmt->apParm = (Tcl_Obj **)&pPreStmt[1];\n#ifdef SQLITE_TEST\n    if( pPreStmt->zSql==0 ){\n      char *zCopy = Tcl_Alloc(pPreStmt->nSql + 1);\n      memcpy(zCopy, zSql, pPreStmt->nSql);\n      zCopy[pPreStmt->nSql] = '\\0';\n      pPreStmt->zSql = zCopy;\n    }\n#endif\n  }\n  assert( pPreStmt );\n  assert( strlen30(pPreStmt->zSql)==pPreStmt->nSql );\n  assert( 0==memcmp(pPreStmt->zSql, zSql, pPreStmt->nSql) );\n\n  /* Bind values to parameters that begin with $ or : */  \n  for(i=1; i<=nVar; i++){\n    const char *zVar = sqlite3_bind_parameter_name(pStmt, i);\n    if( zVar!=0 && (zVar[0]=='$' || zVar[0]==':' || zVar[0]=='@') ){\n      Tcl_Obj *pVar = Tcl_GetVar2Ex(interp, &zVar[1], 0, 0);\n      if( pVar ){\n        int n;\n        u8 *data;\n        const char *zType = (pVar->typePtr ? pVar->typePtr->name : \"\");\n        char c = zType[0];\n        if( zVar[0]=='@' ||\n           (c=='b' && strcmp(zType,\"bytearray\")==0 && pVar->bytes==0) ){\n          /* Load a BLOB type if the Tcl variable is a bytearray and\n          ** it has no string representation or the host\n          ** parameter name begins with \"@\". */\n          data = Tcl_GetByteArrayFromObj(pVar, &n);\n          sqlite3_bind_blob(pStmt, i, data, n, SQLITE_STATIC);\n          Tcl_IncrRefCount(pVar);\n          pPreStmt->apParm[iParm++] = pVar;\n        }else if( c=='b' && strcmp(zType,\"boolean\")==0 ){\n          Tcl_GetIntFromObj(interp, pVar, &n);\n          sqlite3_bind_int(pStmt, i, n);\n        }else if( c=='d' && strcmp(zType,\"double\")==0 ){\n          double r;\n          Tcl_GetDoubleFromObj(interp, pVar, &r);\n          sqlite3_bind_double(pStmt, i, r);\n        }else if( (c=='w' && strcmp(zType,\"wideInt\")==0) ||\n              (c=='i' && strcmp(zType,\"int\")==0) ){\n          Tcl_WideInt v;\n          Tcl_GetWideIntFromObj(interp, pVar, &v);\n          sqlite3_bind_int64(pStmt, i, v);\n        }else{\n          data = (unsigned char *)Tcl_GetStringFromObj(pVar, &n);\n          sqlite3_bind_text(pStmt, i, (char *)data, n, SQLITE_STATIC);\n          Tcl_IncrRefCount(pVar);\n          pPreStmt->apParm[iParm++] = pVar;\n        }\n      }else{\n        sqlite3_bind_null(pStmt, i);\n      }\n    }\n  }\n  pPreStmt->nParm = iParm;\n  *ppPreStmt = pPreStmt;\n\n  return TCL_OK;\n}\n\n/*\n** Release a statement reference obtained by calling dbPrepareAndBind().\n** There should be exactly one call to this function for each call to\n** dbPrepareAndBind().\n**\n** If the discard parameter is non-zero, then the statement is deleted\n** immediately. Otherwise it is added to the LRU list and may be returned\n** by a subsequent call to dbPrepareAndBind().\n*/\nstatic void dbReleaseStmt(\n  SqliteDb *pDb,                  /* Database handle */\n  SqlPreparedStmt *pPreStmt,      /* Prepared statement handle to release */\n  int discard                     /* True to delete (not cache) the pPreStmt */\n){\n  int i;\n\n  /* Free the bound string and blob parameters */\n  for(i=0; i<pPreStmt->nParm; i++){\n    Tcl_DecrRefCount(pPreStmt->apParm[i]);\n  }\n  pPreStmt->nParm = 0;\n\n  if( pDb->maxStmt<=0 || discard ){\n    /* If the cache is turned off, deallocated the statement */\n    dbFreeStmt(pPreStmt);\n  }else{\n    /* Add the prepared statement to the beginning of the cache list. */\n    pPreStmt->pNext = pDb->stmtList;\n    pPreStmt->pPrev = 0;\n    if( pDb->stmtList ){\n     pDb->stmtList->pPrev = pPreStmt;\n    }\n    pDb->stmtList = pPreStmt;\n    if( pDb->stmtLast==0 ){\n      assert( pDb->nStmt==0 );\n      pDb->stmtLast = pPreStmt;\n    }else{\n      assert( pDb->nStmt>0 );\n    }\n    pDb->nStmt++;\n   \n    /* If we have too many statement in cache, remove the surplus from \n    ** the end of the cache list.  */\n    while( pDb->nStmt>pDb->maxStmt ){\n      SqlPreparedStmt *pLast = pDb->stmtLast;\n      pDb->stmtLast = pLast->pPrev;\n      pDb->stmtLast->pNext = 0;\n      pDb->nStmt--;\n      dbFreeStmt(pLast);\n    }\n  }\n}\n\n/*\n** Structure used with dbEvalXXX() functions:\n**\n**   dbEvalInit()\n**   dbEvalStep()\n**   dbEvalFinalize()\n**   dbEvalRowInfo()\n**   dbEvalColumnValue()\n*/\ntypedef struct DbEvalContext DbEvalContext;\nstruct DbEvalContext {\n  SqliteDb *pDb;                  /* Database handle */\n  Tcl_Obj *pSql;                  /* Object holding string zSql */\n  const char *zSql;               /* Remaining SQL to execute */\n  SqlPreparedStmt *pPreStmt;      /* Current statement */\n  int nCol;                       /* Number of columns returned by pStmt */\n  Tcl_Obj *pArray;                /* Name of array variable */\n  Tcl_Obj **apColName;            /* Array of column names */\n};\n\n/*\n** Release any cache of column names currently held as part of\n** the DbEvalContext structure passed as the first argument.\n*/\nstatic void dbReleaseColumnNames(DbEvalContext *p){\n  if( p->apColName ){\n    int i;\n    for(i=0; i<p->nCol; i++){\n      Tcl_DecrRefCount(p->apColName[i]);\n    }\n    Tcl_Free((char *)p->apColName);\n    p->apColName = 0;\n  }\n  p->nCol = 0;\n}\n\n/*\n** Initialize a DbEvalContext structure.\n**\n** If pArray is not NULL, then it contains the name of a Tcl array\n** variable. The \"*\" member of this array is set to a list containing\n** the names of the columns returned by the statement as part of each\n** call to dbEvalStep(), in order from left to right. e.g. if the names \n** of the returned columns are a, b and c, it does the equivalent of the \n** tcl command:\n**\n**     set ${pArray}(*) {a b c}\n*/\nstatic void dbEvalInit(\n  DbEvalContext *p,               /* Pointer to structure to initialize */\n  SqliteDb *pDb,                  /* Database handle */\n  Tcl_Obj *pSql,                  /* Object containing SQL script */\n  Tcl_Obj *pArray                 /* Name of Tcl array to set (*) element of */\n){\n  memset(p, 0, sizeof(DbEvalContext));\n  p->pDb = pDb;\n  p->zSql = Tcl_GetString(pSql);\n  p->pSql = pSql;\n  Tcl_IncrRefCount(pSql);\n  if( pArray ){\n    p->pArray = pArray;\n    Tcl_IncrRefCount(pArray);\n  }\n}\n\n/*\n** Obtain information about the row that the DbEvalContext passed as the\n** first argument currently points to.\n*/\nstatic void dbEvalRowInfo(\n  DbEvalContext *p,               /* Evaluation context */\n  int *pnCol,                     /* OUT: Number of column names */\n  Tcl_Obj ***papColName           /* OUT: Array of column names */\n){\n  /* Compute column names */\n  if( 0==p->apColName ){\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    int i;                        /* Iterator variable */\n    int nCol;                     /* Number of columns returned by pStmt */\n    Tcl_Obj **apColName = 0;      /* Array of column names */\n\n    p->nCol = nCol = sqlite3_column_count(pStmt);\n    if( nCol>0 && (papColName || p->pArray) ){\n      apColName = (Tcl_Obj**)Tcl_Alloc( sizeof(Tcl_Obj*)*nCol );\n      for(i=0; i<nCol; i++){\n        apColName[i] = Tcl_NewStringObj(sqlite3_column_name(pStmt,i), -1);\n        Tcl_IncrRefCount(apColName[i]);\n      }\n      p->apColName = apColName;\n    }\n\n    /* If results are being stored in an array variable, then create\n    ** the array(*) entry for that array\n    */\n    if( p->pArray ){\n      Tcl_Interp *interp = p->pDb->interp;\n      Tcl_Obj *pColList = Tcl_NewObj();\n      Tcl_Obj *pStar = Tcl_NewStringObj(\"*\", -1);\n\n      for(i=0; i<nCol; i++){\n        Tcl_ListObjAppendElement(interp, pColList, apColName[i]);\n      }\n      Tcl_IncrRefCount(pStar);\n      Tcl_ObjSetVar2(interp, p->pArray, pStar, pColList, 0);\n      Tcl_DecrRefCount(pStar);\n    }\n  }\n\n  if( papColName ){\n    *papColName = p->apColName;\n  }\n  if( pnCol ){\n    *pnCol = p->nCol;\n  }\n}\n\n/*\n** Return one of TCL_OK, TCL_BREAK or TCL_ERROR. If TCL_ERROR is\n** returned, then an error message is stored in the interpreter before\n** returning.\n**\n** A return value of TCL_OK means there is a row of data available. The\n** data may be accessed using dbEvalRowInfo() and dbEvalColumnValue(). This\n** is analogous to a return of SQLITE_ROW from sqlite3_step(). If TCL_BREAK\n** is returned, then the SQL script has finished executing and there are\n** no further rows available. This is similar to SQLITE_DONE.\n*/\nstatic int dbEvalStep(DbEvalContext *p){\n  const char *zPrevSql = 0;       /* Previous value of p->zSql */\n\n  while( p->zSql[0] || p->pPreStmt ){\n    int rc;\n    if( p->pPreStmt==0 ){\n      zPrevSql = (p->zSql==zPrevSql ? 0 : p->zSql);\n      rc = dbPrepareAndBind(p->pDb, p->zSql, &p->zSql, &p->pPreStmt);\n      if( rc!=TCL_OK ) return rc;\n    }else{\n      int rcs;\n      SqliteDb *pDb = p->pDb;\n      SqlPreparedStmt *pPreStmt = p->pPreStmt;\n      sqlite3_stmt *pStmt = pPreStmt->pStmt;\n\n      rcs = sqlite3_step(pStmt);\n      if( rcs==SQLITE_ROW ){\n        return TCL_OK;\n      }\n      if( p->pArray ){\n        dbEvalRowInfo(p, 0, 0);\n      }\n      rcs = sqlite3_reset(pStmt);\n\n      pDb->nStep = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_FULLSCAN_STEP,1);\n      pDb->nSort = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_SORT,1);\n      pDb->nIndex = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_AUTOINDEX,1);\n      dbReleaseColumnNames(p);\n      p->pPreStmt = 0;\n\n      if( rcs!=SQLITE_OK ){\n        /* If a run-time error occurs, report the error and stop reading\n        ** the SQL.  */\n        dbReleaseStmt(pDb, pPreStmt, 1);\n#if SQLITE_TEST\n        if( p->pDb->bLegacyPrepare && rcs==SQLITE_SCHEMA && zPrevSql ){\n          /* If the runtime error was an SQLITE_SCHEMA, and the database\n          ** handle is configured to use the legacy sqlite3_prepare() \n          ** interface, retry prepare()/step() on the same SQL statement.\n          ** This only happens once. If there is a second SQLITE_SCHEMA\n          ** error, the error will be returned to the caller. */\n          p->zSql = zPrevSql;\n          continue;\n        }\n#endif\n        Tcl_SetObjResult(pDb->interp,\n                         Tcl_NewStringObj(sqlite3_errmsg(pDb->db), -1));\n        return TCL_ERROR;\n      }else{\n        dbReleaseStmt(pDb, pPreStmt, 0);\n      }\n    }\n  }\n\n  /* Finished */\n  return TCL_BREAK;\n}\n\n/*\n** Free all resources currently held by the DbEvalContext structure passed\n** as the first argument. There should be exactly one call to this function\n** for each call to dbEvalInit().\n*/\nstatic void dbEvalFinalize(DbEvalContext *p){\n  if( p->pPreStmt ){\n    sqlite3_reset(p->pPreStmt->pStmt);\n    dbReleaseStmt(p->pDb, p->pPreStmt, 0);\n    p->pPreStmt = 0;\n  }\n  if( p->pArray ){\n    Tcl_DecrRefCount(p->pArray);\n    p->pArray = 0;\n  }\n  Tcl_DecrRefCount(p->pSql);\n  dbReleaseColumnNames(p);\n}\n\n/*\n** Return a pointer to a Tcl_Obj structure with ref-count 0 that contains\n** the value for the iCol'th column of the row currently pointed to by\n** the DbEvalContext structure passed as the first argument.\n*/\nstatic Tcl_Obj *dbEvalColumnValue(DbEvalContext *p, int iCol){\n  sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n  switch( sqlite3_column_type(pStmt, iCol) ){\n    case SQLITE_BLOB: {\n      int bytes = sqlite3_column_bytes(pStmt, iCol);\n      const char *zBlob = sqlite3_column_blob(pStmt, iCol);\n      if( !zBlob ) bytes = 0;\n      return Tcl_NewByteArrayObj((u8*)zBlob, bytes);\n    }\n    case SQLITE_INTEGER: {\n      sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n      if( v>=-2147483647 && v<=2147483647 ){\n        return Tcl_NewIntObj((int)v);\n      }else{\n        return Tcl_NewWideIntObj(v);\n      }\n    }\n    case SQLITE_FLOAT: {\n      return Tcl_NewDoubleObj(sqlite3_column_double(pStmt, iCol));\n    }\n    case SQLITE_NULL: {\n      return Tcl_NewStringObj(p->pDb->zNull, -1);\n    }\n  }\n\n  return Tcl_NewStringObj((char*)sqlite3_column_text(pStmt, iCol), -1);\n}\n\n/*\n** If using Tcl version 8.6 or greater, use the NR functions to avoid\n** recursive evalution of scripts by the [db eval] and [db trans]\n** commands. Even if the headers used while compiling the extension\n** are 8.6 or newer, the code still tests the Tcl version at runtime.\n** This allows stubs-enabled builds to be used with older Tcl libraries.\n*/\n#if TCL_MAJOR_VERSION>8 || (TCL_MAJOR_VERSION==8 && TCL_MINOR_VERSION>=6)\n# define SQLITE_TCL_NRE 1\nstatic int DbUseNre(void){\n  int major, minor;\n  Tcl_GetVersion(&major, &minor, 0, 0);\n  return( (major==8 && minor>=6) || major>8 );\n}\n#else\n/* \n** Compiling using headers earlier than 8.6. In this case NR cannot be\n** used, so DbUseNre() to always return zero. Add #defines for the other\n** Tcl_NRxxx() functions to prevent them from causing compilation errors,\n** even though the only invocations of them are within conditional blocks \n** of the form:\n**\n**   if( DbUseNre() ) { ... }\n*/\n# define SQLITE_TCL_NRE 0\n# define DbUseNre() 0\n# define Tcl_NRAddCallback(a,b,c,d,e,f) 0\n# define Tcl_NREvalObj(a,b,c) 0\n# define Tcl_NRCreateCommand(a,b,c,d,e,f) 0\n#endif\n\n/*\n** This function is part of the implementation of the command:\n**\n**   $db eval SQL ?ARRAYNAME? SCRIPT\n*/\nstatic int DbEvalNextCmd(\n  ClientData data[],                   /* data[0] is the (DbEvalContext*) */\n  Tcl_Interp *interp,                  /* Tcl interpreter */\n  int result                           /* Result so far */\n){\n  int rc = result;                     /* Return code */\n\n  /* The first element of the data[] array is a pointer to a DbEvalContext\n  ** structure allocated using Tcl_Alloc(). The second element of data[]\n  ** is a pointer to a Tcl_Obj containing the script to run for each row\n  ** returned by the queries encapsulated in data[0]. */\n  DbEvalContext *p = (DbEvalContext *)data[0];\n  Tcl_Obj *pScript = (Tcl_Obj *)data[1];\n  Tcl_Obj *pArray = p->pArray;\n\n  while( (rc==TCL_OK || rc==TCL_CONTINUE) && TCL_OK==(rc = dbEvalStep(p)) ){\n    int i;\n    int nCol;\n    Tcl_Obj **apColName;\n    dbEvalRowInfo(p, &nCol, &apColName);\n    for(i=0; i<nCol; i++){\n      Tcl_Obj *pVal = dbEvalColumnValue(p, i);\n      if( pArray==0 ){\n        Tcl_ObjSetVar2(interp, apColName[i], 0, pVal, 0);\n      }else{\n        Tcl_ObjSetVar2(interp, pArray, apColName[i], pVal, 0);\n      }\n    }\n\n    /* The required interpreter variables are now populated with the data \n    ** from the current row. If using NRE, schedule callbacks to evaluate\n    ** script pScript, then to invoke this function again to fetch the next\n    ** row (or clean up if there is no next row or the script throws an\n    ** exception). After scheduling the callbacks, return control to the \n    ** caller.\n    **\n    ** If not using NRE, evaluate pScript directly and continue with the\n    ** next iteration of this while(...) loop.  */\n    if( DbUseNre() ){\n      Tcl_NRAddCallback(interp, DbEvalNextCmd, (void*)p, (void*)pScript, 0, 0);\n      return Tcl_NREvalObj(interp, pScript, 0);\n    }else{\n      rc = Tcl_EvalObjEx(interp, pScript, 0);\n    }\n  }\n\n  Tcl_DecrRefCount(pScript);\n  dbEvalFinalize(p);\n  Tcl_Free((char *)p);\n\n  if( rc==TCL_OK || rc==TCL_BREAK ){\n    Tcl_ResetResult(interp);\n    rc = TCL_OK;\n  }\n  return rc;\n}\n\n/*\n** The \"sqlite\" command below creates a new Tcl command for each\n** connection it opens to an SQLite database.  This routine is invoked\n** whenever one of those connection-specific commands is executed\n** in Tcl.  For example, if you run Tcl code like this:\n**\n**       sqlite3 db1  \"my_database\"\n**       db1 close\n**\n** The first command opens a connection to the \"my_database\" database\n** and calls that connection \"db1\".  The second command causes this\n** subroutine to be invoked.\n*/\nstatic int DbObjCmd(void *cd, Tcl_Interp *interp, int objc,Tcl_Obj *const*objv){\n  SqliteDb *pDb = (SqliteDb*)cd;\n  int choice;\n  int rc = TCL_OK;\n  static const char *DB_strs[] = {\n    \"authorizer\",         \"backup\",            \"busy\",\n    \"cache\",              \"changes\",           \"close\",\n    \"collate\",            \"collation_needed\",  \"commit_hook\",\n    \"complete\",           \"copy\",              \"enable_load_extension\",\n    \"errorcode\",          \"eval\",              \"exists\",\n    \"function\",           \"incrblob\",          \"interrupt\",\n    \"last_insert_rowid\",  \"nullvalue\",         \"onecolumn\",\n    \"profile\",            \"progress\",          \"rekey\",\n    \"restore\",            \"rollback_hook\",     \"status\",\n    \"timeout\",            \"total_changes\",     \"trace\",\n    \"transaction\",        \"unlock_notify\",     \"update_hook\",\n    \"version\",            \"wal_hook\",          0\n  };\n  enum DB_enum {\n    DB_AUTHORIZER,        DB_BACKUP,           DB_BUSY,\n    DB_CACHE,             DB_CHANGES,          DB_CLOSE,\n    DB_COLLATE,           DB_COLLATION_NEEDED, DB_COMMIT_HOOK,\n    DB_COMPLETE,          DB_COPY,             DB_ENABLE_LOAD_EXTENSION,\n    DB_ERRORCODE,         DB_EVAL,             DB_EXISTS,\n    DB_FUNCTION,          DB_INCRBLOB,         DB_INTERRUPT,\n    DB_LAST_INSERT_ROWID, DB_NULLVALUE,        DB_ONECOLUMN,\n    DB_PROFILE,           DB_PROGRESS,         DB_REKEY,\n    DB_RESTORE,           DB_ROLLBACK_HOOK,    DB_STATUS,\n    DB_TIMEOUT,           DB_TOTAL_CHANGES,    DB_TRACE,\n    DB_TRANSACTION,       DB_UNLOCK_NOTIFY,    DB_UPDATE_HOOK,\n    DB_VERSION,           DB_WAL_HOOK\n  };\n  /* don't leave trailing commas on DB_enum, it confuses the AIX xlc compiler */\n\n  if( objc<2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"SUBCOMMAND ...\");\n    return TCL_ERROR;\n  }\n  if( Tcl_GetIndexFromObj(interp, objv[1], DB_strs, \"option\", 0, &choice) ){\n    return TCL_ERROR;\n  }\n\n  switch( (enum DB_enum)choice ){\n\n  /*    $db authorizer ?CALLBACK?\n  **\n  ** Invoke the given callback to authorize each SQL operation as it is\n  ** compiled.  5 arguments are appended to the callback before it is\n  ** invoked:\n  **\n  **   (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...)\n  **   (2) First descriptive name (depends on authorization type)\n  **   (3) Second descriptive name\n  **   (4) Name of the database (ex: \"main\", \"temp\")\n  **   (5) Name of trigger that is doing the access\n  **\n  ** The callback should return on of the following strings: SQLITE_OK,\n  ** SQLITE_IGNORE, or SQLITE_DENY.  Any other return value is an error.\n  **\n  ** If this method is invoked with no arguments, the current authorization\n  ** callback string is returned.\n  */\n  case DB_AUTHORIZER: {\n#ifdef SQLITE_OMIT_AUTHORIZATION\n    Tcl_AppendResult(interp, \"authorization not available in this build\", 0);\n    return TCL_ERROR;\n#else\n    if( objc>3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"?CALLBACK?\");\n      return TCL_ERROR;\n    }else if( objc==2 ){\n      if( pDb->zAuth ){\n        Tcl_AppendResult(interp, pDb->zAuth, 0);\n      }\n    }else{\n      char *zAuth;\n      int len;\n      if( pDb->zAuth ){\n        Tcl_Free(pDb->zAuth);\n      }\n      zAuth = Tcl_GetStringFromObj(objv[2], &len);\n      if( zAuth && len>0 ){\n        pDb->zAuth = Tcl_Alloc( len + 1 );\n        memcpy(pDb->zAuth, zAuth, len+1);\n      }else{\n        pDb->zAuth = 0;\n      }\n      if( pDb->zAuth ){\n        pDb->interp = interp;\n        sqlite3_set_authorizer(pDb->db, auth_callback, pDb);\n      }else{\n        sqlite3_set_authorizer(pDb->db, 0, 0);\n      }\n    }\n#endif\n    break;\n  }\n\n  /*    $db backup ?DATABASE? FILENAME\n  **\n  ** Open or create a database file named FILENAME.  Transfer the\n  ** content of local database DATABASE (default: \"main\") into the\n  ** FILENAME database.\n  */\n  case DB_BACKUP: {\n    const char *zDestFile;\n    const char *zSrcDb;\n    sqlite3 *pDest;\n    sqlite3_backup *pBackup;\n\n    if( objc==3 ){\n      zSrcDb = \"main\";\n      zDestFile = Tcl_GetString(objv[2]);\n    }else if( objc==4 ){\n      zSrcDb = Tcl_GetString(objv[2]);\n      zDestFile = Tcl_GetString(objv[3]);\n    }else{\n      Tcl_WrongNumArgs(interp, 2, objv, \"?DATABASE? FILENAME\");\n      return TCL_ERROR;\n    }\n    rc = sqlite3_open(zDestFile, &pDest);\n    if( rc!=SQLITE_OK ){\n      Tcl_AppendResult(interp, \"cannot open target database: \",\n           sqlite3_errmsg(pDest), (char*)0);\n      sqlite3_close(pDest);\n      return TCL_ERROR;\n    }\n    pBackup = sqlite3_backup_init(pDest, \"main\", pDb->db, zSrcDb);\n    if( pBackup==0 ){\n      Tcl_AppendResult(interp, \"backup failed: \",\n           sqlite3_errmsg(pDest), (char*)0);\n      sqlite3_close(pDest);\n      return TCL_ERROR;\n    }\n    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}\n    sqlite3_backup_finish(pBackup);\n    if( rc==SQLITE_DONE ){\n      rc = TCL_OK;\n    }else{\n      Tcl_AppendResult(interp, \"backup failed: \",\n           sqlite3_errmsg(pDest), (char*)0);\n      rc = TCL_ERROR;\n    }\n    sqlite3_close(pDest);\n    break;\n  }\n\n  /*    $db busy ?CALLBACK?\n  **\n  ** Invoke the given callback if an SQL statement attempts to open\n  ** a locked database file.\n  */\n  case DB_BUSY: {\n    if( objc>3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"CALLBACK\");\n      return TCL_ERROR;\n    }else if( objc==2 ){\n      if( pDb->zBusy ){\n        Tcl_AppendResult(interp, pDb->zBusy, 0);\n      }\n    }else{\n      char *zBusy;\n      int len;\n      if( pDb->zBusy ){\n        Tcl_Free(pDb->zBusy);\n      }\n      zBusy = Tcl_GetStringFromObj(objv[2], &len);\n      if( zBusy && len>0 ){\n        pDb->zBusy = Tcl_Alloc( len + 1 );\n        memcpy(pDb->zBusy, zBusy, len+1);\n      }else{\n        pDb->zBusy = 0;\n      }\n      if( pDb->zBusy ){\n        pDb->interp = interp;\n        sqlite3_busy_handler(pDb->db, DbBusyHandler, pDb);\n      }else{\n        sqlite3_busy_handler(pDb->db, 0, 0);\n      }\n    }\n    break;\n  }\n\n  /*     $db cache flush\n  **     $db cache size n\n  **\n  ** Flush the prepared statement cache, or set the maximum number of\n  ** cached statements.\n  */\n  case DB_CACHE: {\n    char *subCmd;\n    int n;\n\n    if( objc<=2 ){\n      Tcl_WrongNumArgs(interp, 1, objv, \"cache option ?arg?\");\n      return TCL_ERROR;\n    }\n    subCmd = Tcl_GetStringFromObj( objv[2], 0 );\n    if( *subCmd=='f' && strcmp(subCmd,\"flush\")==0 ){\n      if( objc!=3 ){\n        Tcl_WrongNumArgs(interp, 2, objv, \"flush\");\n        return TCL_ERROR;\n      }else{\n        flushStmtCache( pDb );\n      }\n    }else if( *subCmd=='s' && strcmp(subCmd,\"size\")==0 ){\n      if( objc!=4 ){\n        Tcl_WrongNumArgs(interp, 2, objv, \"size n\");\n        return TCL_ERROR;\n      }else{\n        if( TCL_ERROR==Tcl_GetIntFromObj(interp, objv[3], &n) ){\n          Tcl_AppendResult( interp, \"cannot convert \\\"\", \n               Tcl_GetStringFromObj(objv[3],0), \"\\\" to integer\", 0);\n          return TCL_ERROR;\n        }else{\n          if( n<0 ){\n            flushStmtCache( pDb );\n            n = 0;\n          }else if( n>MAX_PREPARED_STMTS ){\n            n = MAX_PREPARED_STMTS;\n          }\n          pDb->maxStmt = n;\n        }\n      }\n    }else{\n      Tcl_AppendResult( interp, \"bad option \\\"\", \n          Tcl_GetStringFromObj(objv[2],0), \"\\\": must be flush or size\", 0);\n      return TCL_ERROR;\n    }\n    break;\n  }\n\n  /*     $db changes\n  **\n  ** Return the number of rows that were modified, inserted, or deleted by\n  ** the most recent INSERT, UPDATE or DELETE statement, not including \n  ** any changes made by trigger programs.\n  */\n  case DB_CHANGES: {\n    Tcl_Obj *pResult;\n    if( objc!=2 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"\");\n      return TCL_ERROR;\n    }\n    pResult = Tcl_GetObjResult(interp);\n    Tcl_SetIntObj(pResult, sqlite3_changes(pDb->db));\n    break;\n  }\n\n  /*    $db close\n  **\n  ** Shutdown the database\n  */\n  case DB_CLOSE: {\n    Tcl_DeleteCommand(interp, Tcl_GetStringFromObj(objv[0], 0));\n    break;\n  }\n\n  /*\n  **     $db collate NAME SCRIPT\n  **\n  ** Create a new SQL collation function called NAME.  Whenever\n  ** that function is called, invoke SCRIPT to evaluate the function.\n  */\n  case DB_COLLATE: {\n    SqlCollate *pCollate;\n    char *zName;\n    char *zScript;\n    int nScript;\n    if( objc!=4 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"NAME SCRIPT\");\n      return TCL_ERROR;\n    }\n    zName = Tcl_GetStringFromObj(objv[2], 0);\n    zScript = Tcl_GetStringFromObj(objv[3], &nScript);\n    pCollate = (SqlCollate*)Tcl_Alloc( sizeof(*pCollate) + nScript + 1 );\n    if( pCollate==0 ) return TCL_ERROR;\n    pCollate->interp = interp;\n    pCollate->pNext = pDb->pCollate;\n    pCollate->zScript = (char*)&pCollate[1];\n    pDb->pCollate = pCollate;\n    memcpy(pCollate->zScript, zScript, nScript+1);\n    if( sqlite3_create_collation(pDb->db, zName, SQLITE_UTF8, \n        pCollate, tclSqlCollate) ){\n      Tcl_SetResult(interp, (char *)sqlite3_errmsg(pDb->db), TCL_VOLATILE);\n      return TCL_ERROR;\n    }\n    break;\n  }\n\n  /*\n  **     $db collation_needed SCRIPT\n  **\n  ** Create a new SQL collation function called NAME.  Whenever\n  ** that function is called, invoke SCRIPT to evaluate the function.\n  */\n  case DB_COLLATION_NEEDED: {\n    if( objc!=3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"SCRIPT\");\n      return TCL_ERROR;\n    }\n    if( pDb->pCollateNeeded ){\n      Tcl_DecrRefCount(pDb->pCollateNeeded);\n    }\n    pDb->pCollateNeeded = Tcl_DuplicateObj(objv[2]);\n    Tcl_IncrRefCount(pDb->pCollateNeeded);\n    sqlite3_collation_needed(pDb->db, pDb, tclCollateNeeded);\n    break;\n  }\n\n  /*    $db commit_hook ?CALLBACK?\n  **\n  ** Invoke the given callback just before committing every SQL transaction.\n  ** If the callback throws an exception or returns non-zero, then the\n  ** transaction is aborted.  If CALLBACK is an empty string, the callback\n  ** is disabled.\n  */\n  case DB_COMMIT_HOOK: {\n    if( objc>3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"?CALLBACK?\");\n      return TCL_ERROR;\n    }else if( objc==2 ){\n      if( pDb->zCommit ){\n        Tcl_AppendResult(interp, pDb->zCommit, 0);\n      }\n    }else{\n      char *zCommit;\n      int len;\n      if( pDb->zCommit ){\n        Tcl_Free(pDb->zCommit);\n      }\n      zCommit = Tcl_GetStringFromObj(objv[2], &len);\n      if( zCommit && len>0 ){\n        pDb->zCommit = Tcl_Alloc( len + 1 );\n        memcpy(pDb->zCommit, zCommit, len+1);\n      }else{\n        pDb->zCommit = 0;\n      }\n      if( pDb->zCommit ){\n        pDb->interp = interp;\n        sqlite3_commit_hook(pDb->db, DbCommitHandler, pDb);\n      }else{\n        sqlite3_commit_hook(pDb->db, 0, 0);\n      }\n    }\n    break;\n  }\n\n  /*    $db complete SQL\n  **\n  ** Return TRUE if SQL is a complete SQL statement.  Return FALSE if\n  ** additional lines of input are needed.  This is similar to the\n  ** built-in \"info complete\" command of Tcl.\n  */\n  case DB_COMPLETE: {\n#ifndef SQLITE_OMIT_COMPLETE\n    Tcl_Obj *pResult;\n    int isComplete;\n    if( objc!=3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"SQL\");\n      return TCL_ERROR;\n    }\n    isComplete = sqlite3_complete( Tcl_GetStringFromObj(objv[2], 0) );\n    pResult = Tcl_GetObjResult(interp);\n    Tcl_SetBooleanObj(pResult, isComplete);\n#endif\n    break;\n  }\n\n  /*    $db copy conflict-algorithm table filename ?SEPARATOR? ?NULLINDICATOR?\n  **\n  ** Copy data into table from filename, optionally using SEPARATOR\n  ** as column separators.  If a column contains a null string, or the\n  ** value of NULLINDICATOR, a NULL is inserted for the column.\n  ** conflict-algorithm is one of the sqlite conflict algorithms:\n  **    rollback, abort, fail, ignore, replace\n  ** On success, return the number of lines processed, not necessarily same\n  ** as 'db changes' due to conflict-algorithm selected.\n  **\n  ** This code is basically an implementation/enhancement of\n  ** the sqlite3 shell.c \".import\" command.\n  **\n  ** This command usage is equivalent to the sqlite2.x COPY statement,\n  ** which imports file data into a table using the PostgreSQL COPY file format:\n  **   $db copy $conflit_algo $table_name $filename \\t \\\\N\n  */\n  case DB_COPY: {\n    char *zTable;               /* Insert data into this table */\n    char *zFile;                /* The file from which to extract data */\n    char *zConflict;            /* The conflict algorithm to use */\n    sqlite3_stmt *pStmt;        /* A statement */\n    int nCol;                   /* Number of columns in the table */\n    int nByte;                  /* Number of bytes in an SQL string */\n    int i, j;                   /* Loop counters */\n    int nSep;                   /* Number of bytes in zSep[] */\n    int nNull;                  /* Number of bytes in zNull[] */\n    char *zSql;                 /* An SQL statement */\n    char *zLine;                /* A single line of input from the file */\n    char **azCol;               /* zLine[] broken up into columns */\n    char *zCommit;              /* How to commit changes */\n    FILE *in;                   /* The input file */\n    int lineno = 0;             /* Line number of input file */\n    char zLineNum[80];          /* Line number print buffer */\n    Tcl_Obj *pResult;           /* interp result */\n\n    char *zSep;\n    char *zNull;\n    if( objc<5 || objc>7 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \n         \"CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?\");\n      return TCL_ERROR;\n    }\n    if( objc>=6 ){\n      zSep = Tcl_GetStringFromObj(objv[5], 0);\n    }else{\n      zSep = \"\\t\";\n    }\n    if( objc>=7 ){\n      zNull = Tcl_GetStringFromObj(objv[6], 0);\n    }else{\n      zNull = \"\";\n    }\n    zConflict = Tcl_GetStringFromObj(objv[2], 0);\n    zTable = Tcl_GetStringFromObj(objv[3], 0);\n    zFile = Tcl_GetStringFromObj(objv[4], 0);\n    nSep = strlen30(zSep);\n    nNull = strlen30(zNull);\n    if( nSep==0 ){\n      Tcl_AppendResult(interp,\"Error: non-null separator required for copy\",0);\n      return TCL_ERROR;\n    }\n    if(strcmp(zConflict, \"rollback\") != 0 &&\n       strcmp(zConflict, \"abort\"   ) != 0 &&\n       strcmp(zConflict, \"fail\"    ) != 0 &&\n       strcmp(zConflict, \"ignore\"  ) != 0 &&\n       strcmp(zConflict, \"replace\" ) != 0 ) {\n      Tcl_AppendResult(interp, \"Error: \\\"\", zConflict, \n            \"\\\", conflict-algorithm must be one of: rollback, \"\n            \"abort, fail, ignore, or replace\", 0);\n      return TCL_ERROR;\n    }\n    zSql = sqlite3_mprintf(\"SELECT * FROM '%q'\", zTable);\n    if( zSql==0 ){\n      Tcl_AppendResult(interp, \"Error: no such table: \", zTable, 0);\n      return TCL_ERROR;\n    }\n    nByte = strlen30(zSql);\n    rc = sqlite3_prepare(pDb->db, zSql, -1, &pStmt, 0);\n    sqlite3_free(zSql);\n    if( rc ){\n      Tcl_AppendResult(interp, \"Error: \", sqlite3_errmsg(pDb->db), 0);\n      nCol = 0;\n    }else{\n      nCol = sqlite3_column_count(pStmt);\n    }\n    sqlite3_finalize(pStmt);\n    if( nCol==0 ) {\n      return TCL_ERROR;\n    }\n    zSql = malloc( nByte + 50 + nCol*2 );\n    if( zSql==0 ) {\n      Tcl_AppendResult(interp, \"Error: can't malloc()\", 0);\n      return TCL_ERROR;\n    }\n    sqlite3_snprintf(nByte+50, zSql, \"INSERT OR %q INTO '%q' VALUES(?\",\n         zConflict, zTable);\n    j = strlen30(zSql);\n    for(i=1; i<nCol; i++){\n      zSql[j++] = ',';\n      zSql[j++] = '?';\n    }\n    zSql[j++] = ')';\n    zSql[j] = 0;\n    rc = sqlite3_prepare(pDb->db, zSql, -1, &pStmt, 0);\n    free(zSql);\n    if( rc ){\n      Tcl_AppendResult(interp, \"Error: \", sqlite3_errmsg(pDb->db), 0);\n      sqlite3_finalize(pStmt);\n      return TCL_ERROR;\n    }\n    in = fopen(zFile, \"rb\");\n    if( in==0 ){\n      Tcl_AppendResult(interp, \"Error: cannot open file: \", zFile, NULL);\n      sqlite3_finalize(pStmt);\n      return TCL_ERROR;\n    }\n    azCol = malloc( sizeof(azCol[0])*(nCol+1) );\n    if( azCol==0 ) {\n      Tcl_AppendResult(interp, \"Error: can't malloc()\", 0);\n      fclose(in);\n      return TCL_ERROR;\n    }\n    (void)sqlite3_exec(pDb->db, \"BEGIN\", 0, 0, 0);\n    zCommit = \"COMMIT\";\n    while( (zLine = local_getline(0, in))!=0 ){\n      char *z;\n      lineno++;\n      azCol[0] = zLine;\n      for(i=0, z=zLine; *z; z++){\n        if( *z==zSep[0] && strncmp(z, zSep, nSep)==0 ){\n          *z = 0;\n          i++;\n          if( i<nCol ){\n            azCol[i] = &z[nSep];\n            z += nSep-1;\n          }\n        }\n      }\n      if( i+1!=nCol ){\n        char *zErr;\n        int nErr = strlen30(zFile) + 200;\n        zErr = malloc(nErr);\n        if( zErr ){\n          sqlite3_snprintf(nErr, zErr,\n             \"Error: %s line %d: expected %d columns of data but found %d\",\n             zFile, lineno, nCol, i+1);\n          Tcl_AppendResult(interp, zErr, 0);\n          free(zErr);\n        }\n        zCommit = \"ROLLBACK\";\n        break;\n      }\n      for(i=0; i<nCol; i++){\n        /* check for null data, if so, bind as null */\n        if( (nNull>0 && strcmp(azCol[i], zNull)==0)\n          || strlen30(azCol[i])==0 \n        ){\n          sqlite3_bind_null(pStmt, i+1);\n        }else{\n          sqlite3_bind_text(pStmt, i+1, azCol[i], -1, SQLITE_STATIC);\n        }\n      }\n      sqlite3_step(pStmt);\n      rc = sqlite3_reset(pStmt);\n      free(zLine);\n      if( rc!=SQLITE_OK ){\n        Tcl_AppendResult(interp,\"Error: \", sqlite3_errmsg(pDb->db), 0);\n        zCommit = \"ROLLBACK\";\n        break;\n      }\n    }\n    free(azCol);\n    fclose(in);\n    sqlite3_finalize(pStmt);\n    (void)sqlite3_exec(pDb->db, zCommit, 0, 0, 0);\n\n    if( zCommit[0] == 'C' ){\n      /* success, set result as number of lines processed */\n      pResult = Tcl_GetObjResult(interp);\n      Tcl_SetIntObj(pResult, lineno);\n      rc = TCL_OK;\n    }else{\n      /* failure, append lineno where failed */\n      sqlite3_snprintf(sizeof(zLineNum), zLineNum,\"%d\",lineno);\n      Tcl_AppendResult(interp,\", failed while processing line: \",zLineNum,0);\n      rc = TCL_ERROR;\n    }\n    break;\n  }\n\n  /*\n  **    $db enable_load_extension BOOLEAN\n  **\n  ** Turn the extension loading feature on or off.  It if off by\n  ** default.\n  */\n  case DB_ENABLE_LOAD_EXTENSION: {\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n    int onoff;\n    if( objc!=3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"BOOLEAN\");\n      return TCL_ERROR;\n    }\n    if( Tcl_GetBooleanFromObj(interp, objv[2], &onoff) ){\n      return TCL_ERROR;\n    }\n    sqlite3_enable_load_extension(pDb->db, onoff);\n    break;\n#else\n    Tcl_AppendResult(interp, \"extension loading is turned off at compile-time\",\n                     0);\n    return TCL_ERROR;\n#endif\n  }\n\n  /*\n  **    $db errorcode\n  **\n  ** Return the numeric error code that was returned by the most recent\n  ** call to sqlite3_exec().\n  */\n  case DB_ERRORCODE: {\n    Tcl_SetObjResult(interp, Tcl_NewIntObj(sqlite3_errcode(pDb->db)));\n    break;\n  }\n\n  /*\n  **    $db exists $sql\n  **    $db onecolumn $sql\n  **\n  ** The onecolumn method is the equivalent of:\n  **     lindex [$db eval $sql] 0\n  */\n  case DB_EXISTS: \n  case DB_ONECOLUMN: {\n    DbEvalContext sEval;\n    if( objc!=3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"SQL\");\n      return TCL_ERROR;\n    }\n\n    dbEvalInit(&sEval, pDb, objv[2], 0);\n    rc = dbEvalStep(&sEval);\n    if( choice==DB_ONECOLUMN ){\n      if( rc==TCL_OK ){\n        Tcl_SetObjResult(interp, dbEvalColumnValue(&sEval, 0));\n      }else if( rc==TCL_BREAK ){\n        Tcl_ResetResult(interp);\n      }\n    }else if( rc==TCL_BREAK || rc==TCL_OK ){\n      Tcl_SetObjResult(interp, Tcl_NewBooleanObj(rc==TCL_OK));\n    }\n    dbEvalFinalize(&sEval);\n\n    if( rc==TCL_BREAK ){\n      rc = TCL_OK;\n    }\n    break;\n  }\n   \n  /*\n  **    $db eval $sql ?array? ?{  ...code... }?\n  **\n  ** The SQL statement in $sql is evaluated.  For each row, the values are\n  ** placed in elements of the array named \"array\" and ...code... is executed.\n  ** If \"array\" and \"code\" are omitted, then no callback is every invoked.\n  ** If \"array\" is an empty string, then the values are placed in variables\n  ** that have the same name as the fields extracted by the query.\n  */\n  case DB_EVAL: {\n    if( objc<3 || objc>5 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"SQL ?ARRAY-NAME? ?SCRIPT?\");\n      return TCL_ERROR;\n    }\n\n    if( objc==3 ){\n      DbEvalContext sEval;\n      Tcl_Obj *pRet = Tcl_NewObj();\n      Tcl_IncrRefCount(pRet);\n      dbEvalInit(&sEval, pDb, objv[2], 0);\n      while( TCL_OK==(rc = dbEvalStep(&sEval)) ){\n        int i;\n        int nCol;\n        dbEvalRowInfo(&sEval, &nCol, 0);\n        for(i=0; i<nCol; i++){\n          Tcl_ListObjAppendElement(interp, pRet, dbEvalColumnValue(&sEval, i));\n        }\n      }\n      dbEvalFinalize(&sEval);\n      if( rc==TCL_BREAK ){\n        Tcl_SetObjResult(interp, pRet);\n        rc = TCL_OK;\n      }\n      Tcl_DecrRefCount(pRet);\n    }else{\n      ClientData cd[2];\n      DbEvalContext *p;\n      Tcl_Obj *pArray = 0;\n      Tcl_Obj *pScript;\n\n      if( objc==5 && *(char *)Tcl_GetString(objv[3]) ){\n        pArray = objv[3];\n      }\n      pScript = objv[objc-1];\n      Tcl_IncrRefCount(pScript);\n      \n      p = (DbEvalContext *)Tcl_Alloc(sizeof(DbEvalContext));\n      dbEvalInit(p, pDb, objv[2], pArray);\n\n      cd[0] = (void *)p;\n      cd[1] = (void *)pScript;\n      rc = DbEvalNextCmd(cd, interp, TCL_OK);\n    }\n    break;\n  }\n\n  /*\n  **     $db function NAME [-argcount N] SCRIPT\n  **\n  ** Create a new SQL function called NAME.  Whenever that function is\n  ** called, invoke SCRIPT to evaluate the function.\n  */\n  case DB_FUNCTION: {\n    SqlFunc *pFunc;\n    Tcl_Obj *pScript;\n    char *zName;\n    int nArg = -1;\n    if( objc==6 ){\n      const char *z = Tcl_GetString(objv[3]);\n      int n = strlen30(z);\n      if( n>2 && strncmp(z, \"-argcount\",n)==0 ){\n        if( Tcl_GetIntFromObj(interp, objv[4], &nArg) ) return TCL_ERROR;\n        if( nArg<0 ){\n          Tcl_AppendResult(interp, \"number of arguments must be non-negative\",\n                           (char*)0);\n          return TCL_ERROR;\n        }\n      }\n      pScript = objv[5];\n    }else if( objc!=4 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"NAME [-argcount N] SCRIPT\");\n      return TCL_ERROR;\n    }else{\n      pScript = objv[3];\n    }\n    zName = Tcl_GetStringFromObj(objv[2], 0);\n    pFunc = findSqlFunc(pDb, zName);\n    if( pFunc==0 ) return TCL_ERROR;\n    if( pFunc->pScript ){\n      Tcl_DecrRefCount(pFunc->pScript);\n    }\n    pFunc->pScript = pScript;\n    Tcl_IncrRefCount(pScript);\n    pFunc->useEvalObjv = safeToUseEvalObjv(interp, pScript);\n    rc = sqlite3_create_function(pDb->db, zName, nArg, SQLITE_UTF8,\n        pFunc, tclSqlFunc, 0, 0);\n    if( rc!=SQLITE_OK ){\n      rc = TCL_ERROR;\n      Tcl_SetResult(interp, (char *)sqlite3_errmsg(pDb->db), TCL_VOLATILE);\n    }\n    break;\n  }\n\n  /*\n  **     $db incrblob ?-readonly? ?DB? TABLE COLUMN ROWID\n  */\n  case DB_INCRBLOB: {\n#ifdef SQLITE_OMIT_INCRBLOB\n    Tcl_AppendResult(interp, \"incrblob not available in this build\", 0);\n    return TCL_ERROR;\n#else\n    int isReadonly = 0;\n    const char *zDb = \"main\";\n    const char *zTable;\n    const char *zColumn;\n    Tcl_WideInt iRow;\n\n    /* Check for the -readonly option */\n    if( objc>3 && strcmp(Tcl_GetString(objv[2]), \"-readonly\")==0 ){\n      isReadonly = 1;\n    }\n\n    if( objc!=(5+isReadonly) && objc!=(6+isReadonly) ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"?-readonly? ?DB? TABLE COLUMN ROWID\");\n      return TCL_ERROR;\n    }\n\n    if( objc==(6+isReadonly) ){\n      zDb = Tcl_GetString(objv[2]);\n    }\n    zTable = Tcl_GetString(objv[objc-3]);\n    zColumn = Tcl_GetString(objv[objc-2]);\n    rc = Tcl_GetWideIntFromObj(interp, objv[objc-1], &iRow);\n\n    if( rc==TCL_OK ){\n      rc = createIncrblobChannel(\n          interp, pDb, zDb, zTable, zColumn, iRow, isReadonly\n      );\n    }\n#endif\n    break;\n  }\n\n  /*\n  **     $db interrupt\n  **\n  ** Interrupt the execution of the inner-most SQL interpreter.  This\n  ** causes the SQL statement to return an error of SQLITE_INTERRUPT.\n  */\n  case DB_INTERRUPT: {\n    sqlite3_interrupt(pDb->db);\n    break;\n  }\n\n  /*\n  **     $db nullvalue ?STRING?\n  **\n  ** Change text used when a NULL comes back from the database. If ?STRING?\n  ** is not present, then the current string used for NULL is returned.\n  ** If STRING is present, then STRING is returned.\n  **\n  */\n  case DB_NULLVALUE: {\n    if( objc!=2 && objc!=3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"NULLVALUE\");\n      return TCL_ERROR;\n    }\n    if( objc==3 ){\n      int len;\n      char *zNull = Tcl_GetStringFromObj(objv[2], &len);\n      if( pDb->zNull ){\n        Tcl_Free(pDb->zNull);\n      }\n      if( zNull && len>0 ){\n        pDb->zNull = Tcl_Alloc( len + 1 );\n        memcpy(pDb->zNull, zNull, len);\n        pDb->zNull[len] = '\\0';\n      }else{\n        pDb->zNull = 0;\n      }\n    }\n    Tcl_SetObjResult(interp, Tcl_NewStringObj(pDb->zNull, -1));\n    break;\n  }\n\n  /*\n  **     $db last_insert_rowid \n  **\n  ** Return an integer which is the ROWID for the most recent insert.\n  */\n  case DB_LAST_INSERT_ROWID: {\n    Tcl_Obj *pResult;\n    Tcl_WideInt rowid;\n    if( objc!=2 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"\");\n      return TCL_ERROR;\n    }\n    rowid = sqlite3_last_insert_rowid(pDb->db);\n    pResult = Tcl_GetObjResult(interp);\n    Tcl_SetWideIntObj(pResult, rowid);\n    break;\n  }\n\n  /*\n  ** The DB_ONECOLUMN method is implemented together with DB_EXISTS.\n  */\n\n  /*    $db progress ?N CALLBACK?\n  ** \n  ** Invoke the given callback every N virtual machine opcodes while executing\n  ** queries.\n  */\n  case DB_PROGRESS: {\n    if( objc==2 ){\n      if( pDb->zProgress ){\n        Tcl_AppendResult(interp, pDb->zProgress, 0);\n      }\n    }else if( objc==4 ){\n      char *zProgress;\n      int len;\n      int N;\n      if( TCL_OK!=Tcl_GetIntFromObj(interp, objv[2], &N) ){\n        return TCL_ERROR;\n      };\n      if( pDb->zProgress ){\n        Tcl_Free(pDb->zProgress);\n      }\n      zProgress = Tcl_GetStringFromObj(objv[3], &len);\n      if( zProgress && len>0 ){\n        pDb->zProgress = Tcl_Alloc( len + 1 );\n        memcpy(pDb->zProgress, zProgress, len+1);\n      }else{\n        pDb->zProgress = 0;\n      }\n#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n      if( pDb->zProgress ){\n        pDb->interp = interp;\n        sqlite3_progress_handler(pDb->db, N, DbProgressHandler, pDb);\n      }else{\n        sqlite3_progress_handler(pDb->db, 0, 0, 0);\n      }\n#endif\n    }else{\n      Tcl_WrongNumArgs(interp, 2, objv, \"N CALLBACK\");\n      return TCL_ERROR;\n    }\n    break;\n  }\n\n  /*    $db profile ?CALLBACK?\n  **\n  ** Make arrangements to invoke the CALLBACK routine after each SQL statement\n  ** that has run.  The text of the SQL and the amount of elapse time are\n  ** appended to CALLBACK before the script is run.\n  */\n  case DB_PROFILE: {\n    if( objc>3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"?CALLBACK?\");\n      return TCL_ERROR;\n    }else if( objc==2 ){\n      if( pDb->zProfile ){\n        Tcl_AppendResult(interp, pDb->zProfile, 0);\n      }\n    }else{\n      char *zProfile;\n      int len;\n      if( pDb->zProfile ){\n        Tcl_Free(pDb->zProfile);\n      }\n      zProfile = Tcl_GetStringFromObj(objv[2], &len);\n      if( zProfile && len>0 ){\n        pDb->zProfile = Tcl_Alloc( len + 1 );\n        memcpy(pDb->zProfile, zProfile, len+1);\n      }else{\n        pDb->zProfile = 0;\n      }\n#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)\n      if( pDb->zProfile ){\n        pDb->interp = interp;\n        sqlite3_profile(pDb->db, DbProfileHandler, pDb);\n      }else{\n        sqlite3_profile(pDb->db, 0, 0);\n      }\n#endif\n    }\n    break;\n  }\n\n  /*\n  **     $db rekey KEY\n  **\n  ** Change the encryption key on the currently open database.\n  */\n  case DB_REKEY: {\n#ifdef SQLITE_HAS_CODEC\n    int nKey;\n    void *pKey;\n#endif\n    if( objc!=3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"KEY\");\n      return TCL_ERROR;\n    }\n#ifdef SQLITE_HAS_CODEC\n    pKey = Tcl_GetByteArrayFromObj(objv[2], &nKey);\n    rc = sqlite3_rekey(pDb->db, pKey, nKey);\n    if( rc ){\n      Tcl_AppendResult(interp, sqlite3_errstr(rc), 0);\n      rc = TCL_ERROR;\n    }\n#endif\n    break;\n  }\n\n  /*    $db restore ?DATABASE? FILENAME\n  **\n  ** Open a database file named FILENAME.  Transfer the content \n  ** of FILENAME into the local database DATABASE (default: \"main\").\n  */\n  case DB_RESTORE: {\n    const char *zSrcFile;\n    const char *zDestDb;\n    sqlite3 *pSrc;\n    sqlite3_backup *pBackup;\n    int nTimeout = 0;\n\n    if( objc==3 ){\n      zDestDb = \"main\";\n      zSrcFile = Tcl_GetString(objv[2]);\n    }else if( objc==4 ){\n      zDestDb = Tcl_GetString(objv[2]);\n      zSrcFile = Tcl_GetString(objv[3]);\n    }else{\n      Tcl_WrongNumArgs(interp, 2, objv, \"?DATABASE? FILENAME\");\n      return TCL_ERROR;\n    }\n    rc = sqlite3_open_v2(zSrcFile, &pSrc, SQLITE_OPEN_READONLY, 0);\n    if( rc!=SQLITE_OK ){\n      Tcl_AppendResult(interp, \"cannot open source database: \",\n           sqlite3_errmsg(pSrc), (char*)0);\n      sqlite3_close(pSrc);\n      return TCL_ERROR;\n    }\n    pBackup = sqlite3_backup_init(pDb->db, zDestDb, pSrc, \"main\");\n    if( pBackup==0 ){\n      Tcl_AppendResult(interp, \"restore failed: \",\n           sqlite3_errmsg(pDb->db), (char*)0);\n      sqlite3_close(pSrc);\n      return TCL_ERROR;\n    }\n    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK\n              || rc==SQLITE_BUSY ){\n      if( rc==SQLITE_BUSY ){\n        if( nTimeout++ >= 3 ) break;\n        sqlite3_sleep(100);\n      }\n    }\n    sqlite3_backup_finish(pBackup);\n    if( rc==SQLITE_DONE ){\n      rc = TCL_OK;\n    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){\n      Tcl_AppendResult(interp, \"restore failed: source database busy\",\n                       (char*)0);\n      rc = TCL_ERROR;\n    }else{\n      Tcl_AppendResult(interp, \"restore failed: \",\n           sqlite3_errmsg(pDb->db), (char*)0);\n      rc = TCL_ERROR;\n    }\n    sqlite3_close(pSrc);\n    break;\n  }\n\n  /*\n  **     $db status (step|sort|autoindex)\n  **\n  ** Display SQLITE_STMTSTATUS_FULLSCAN_STEP or \n  ** SQLITE_STMTSTATUS_SORT for the most recent eval.\n  */\n  case DB_STATUS: {\n    int v;\n    const char *zOp;\n    if( objc!=3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"(step|sort|autoindex)\");\n      return TCL_ERROR;\n    }\n    zOp = Tcl_GetString(objv[2]);\n    if( strcmp(zOp, \"step\")==0 ){\n      v = pDb->nStep;\n    }else if( strcmp(zOp, \"sort\")==0 ){\n      v = pDb->nSort;\n    }else if( strcmp(zOp, \"autoindex\")==0 ){\n      v = pDb->nIndex;\n    }else{\n      Tcl_AppendResult(interp, \n            \"bad argument: should be autoindex, step, or sort\", \n            (char*)0);\n      return TCL_ERROR;\n    }\n    Tcl_SetObjResult(interp, Tcl_NewIntObj(v));\n    break;\n  }\n  \n  /*\n  **     $db timeout MILLESECONDS\n  **\n  ** Delay for the number of milliseconds specified when a file is locked.\n  */\n  case DB_TIMEOUT: {\n    int ms;\n    if( objc!=3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"MILLISECONDS\");\n      return TCL_ERROR;\n    }\n    if( Tcl_GetIntFromObj(interp, objv[2], &ms) ) return TCL_ERROR;\n    sqlite3_busy_timeout(pDb->db, ms);\n    break;\n  }\n  \n  /*\n  **     $db total_changes\n  **\n  ** Return the number of rows that were modified, inserted, or deleted \n  ** since the database handle was created.\n  */\n  case DB_TOTAL_CHANGES: {\n    Tcl_Obj *pResult;\n    if( objc!=2 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"\");\n      return TCL_ERROR;\n    }\n    pResult = Tcl_GetObjResult(interp);\n    Tcl_SetIntObj(pResult, sqlite3_total_changes(pDb->db));\n    break;\n  }\n\n  /*    $db trace ?CALLBACK?\n  **\n  ** Make arrangements to invoke the CALLBACK routine for each SQL statement\n  ** that is executed.  The text of the SQL is appended to CALLBACK before\n  ** it is executed.\n  */\n  case DB_TRACE: {\n    if( objc>3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"?CALLBACK?\");\n      return TCL_ERROR;\n    }else if( objc==2 ){\n      if( pDb->zTrace ){\n        Tcl_AppendResult(interp, pDb->zTrace, 0);\n      }\n    }else{\n      char *zTrace;\n      int len;\n      if( pDb->zTrace ){\n        Tcl_Free(pDb->zTrace);\n      }\n      zTrace = Tcl_GetStringFromObj(objv[2], &len);\n      if( zTrace && len>0 ){\n        pDb->zTrace = Tcl_Alloc( len + 1 );\n        memcpy(pDb->zTrace, zTrace, len+1);\n      }else{\n        pDb->zTrace = 0;\n      }\n#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)\n      if( pDb->zTrace ){\n        pDb->interp = interp;\n        sqlite3_trace(pDb->db, DbTraceHandler, pDb);\n      }else{\n        sqlite3_trace(pDb->db, 0, 0);\n      }\n#endif\n    }\n    break;\n  }\n\n  /*    $db transaction [-deferred|-immediate|-exclusive] SCRIPT\n  **\n  ** Start a new transaction (if we are not already in the midst of a\n  ** transaction) and execute the TCL script SCRIPT.  After SCRIPT\n  ** completes, either commit the transaction or roll it back if SCRIPT\n  ** throws an exception.  Or if no new transation was started, do nothing.\n  ** pass the exception on up the stack.\n  **\n  ** This command was inspired by Dave Thomas's talk on Ruby at the\n  ** 2005 O'Reilly Open Source Convention (OSCON).\n  */\n  case DB_TRANSACTION: {\n    Tcl_Obj *pScript;\n    const char *zBegin = \"SAVEPOINT _tcl_transaction\";\n    if( objc!=3 && objc!=4 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"[TYPE] SCRIPT\");\n      return TCL_ERROR;\n    }\n\n    if( pDb->nTransaction==0 && objc==4 ){\n      static const char *TTYPE_strs[] = {\n        \"deferred\",   \"exclusive\",  \"immediate\", 0\n      };\n      enum TTYPE_enum {\n        TTYPE_DEFERRED, TTYPE_EXCLUSIVE, TTYPE_IMMEDIATE\n      };\n      int ttype;\n      if( Tcl_GetIndexFromObj(interp, objv[2], TTYPE_strs, \"transaction type\",\n                              0, &ttype) ){\n        return TCL_ERROR;\n      }\n      switch( (enum TTYPE_enum)ttype ){\n        case TTYPE_DEFERRED:    /* no-op */;                 break;\n        case TTYPE_EXCLUSIVE:   zBegin = \"BEGIN EXCLUSIVE\";  break;\n        case TTYPE_IMMEDIATE:   zBegin = \"BEGIN IMMEDIATE\";  break;\n      }\n    }\n    pScript = objv[objc-1];\n\n    /* Run the SQLite BEGIN command to open a transaction or savepoint. */\n    pDb->disableAuth++;\n    rc = sqlite3_exec(pDb->db, zBegin, 0, 0, 0);\n    pDb->disableAuth--;\n    if( rc!=SQLITE_OK ){\n      Tcl_AppendResult(interp, sqlite3_errmsg(pDb->db), 0);\n      return TCL_ERROR;\n    }\n    pDb->nTransaction++;\n\n    /* If using NRE, schedule a callback to invoke the script pScript, then\n    ** a second callback to commit (or rollback) the transaction or savepoint\n    ** opened above. If not using NRE, evaluate the script directly, then\n    ** call function DbTransPostCmd() to commit (or rollback) the transaction \n    ** or savepoint.  */\n    if( DbUseNre() ){\n      Tcl_NRAddCallback(interp, DbTransPostCmd, cd, 0, 0, 0);\n      Tcl_NREvalObj(interp, pScript, 0);\n    }else{\n      rc = DbTransPostCmd(&cd, interp, Tcl_EvalObjEx(interp, pScript, 0));\n    }\n    break;\n  }\n\n  /*\n  **    $db unlock_notify ?script?\n  */\n  case DB_UNLOCK_NOTIFY: {\n#ifndef SQLITE_ENABLE_UNLOCK_NOTIFY\n    Tcl_AppendResult(interp, \"unlock_notify not available in this build\", 0);\n    rc = TCL_ERROR;\n#else\n    if( objc!=2 && objc!=3 ){\n      Tcl_WrongNumArgs(interp, 2, objv, \"?SCRIPT?\");\n      rc = TCL_ERROR;\n    }else{\n      void (*xNotify)(void **, int) = 0;\n      void *pNotifyArg = 0;\n\n      if( pDb->pUnlockNotify ){\n        Tcl_DecrRefCount(pDb->pUnlockNotify);\n        pDb->pUnlockNotify = 0;\n      }\n  \n      if( objc==3 ){\n        xNotify = DbUnlockNotify;\n        pNotifyArg = (void *)pDb;\n        pDb->pUnlockNotify = objv[2];\n        Tcl_IncrRefCount(pDb->pUnlockNotify);\n      }\n  \n      if( sqlite3_unlock_notify(pDb->db, xNotify, pNotifyArg) ){\n        Tcl_AppendResult(interp, sqlite3_errmsg(pDb->db), 0);\n        rc = TCL_ERROR;\n      }\n    }\n#endif\n    break;\n  }\n\n  /*\n  **    $db wal_hook ?script?\n  **    $db update_hook ?script?\n  **    $db rollback_hook ?script?\n  */\n  case DB_WAL_HOOK: \n  case DB_UPDATE_HOOK: \n  case DB_ROLLBACK_HOOK: {\n\n    /* set ppHook to point at pUpdateHook or pRollbackHook, depending on \n    ** whether [$db update_hook] or [$db rollback_hook] was invoked.\n    */\n    Tcl_Obj **ppHook; \n    if( choice==DB_UPDATE_HOOK ){\n      ppHook = &pDb->pUpdateHook;\n    }else if( choice==DB_WAL_HOOK ){\n      ppHook = &pDb->pWalHook;\n    }else{\n      ppHook = &pDb->pRollbackHook;\n    }\n\n    if( objc!=2 && objc!=3 ){\n       Tcl_WrongNumArgs(interp, 2, objv, \"?SCRIPT?\");\n       return TCL_ERROR;\n    }\n    if( *ppHook ){\n      Tcl_SetObjResult(interp, *ppHook);\n      if( objc==3 ){\n        Tcl_DecrRefCount(*ppHook);\n        *ppHook = 0;\n      }\n    }\n    if( objc==3 ){\n      assert( !(*ppHook) );\n      if( Tcl_GetCharLength(objv[2])>0 ){\n        *ppHook = objv[2];\n        Tcl_IncrRefCount(*ppHook);\n      }\n    }\n\n    sqlite3_update_hook(pDb->db, (pDb->pUpdateHook?DbUpdateHandler:0), pDb);\n    sqlite3_rollback_hook(pDb->db,(pDb->pRollbackHook?DbRollbackHandler:0),pDb);\n    sqlite3_wal_hook(pDb->db,(pDb->pWalHook?DbWalHandler:0),pDb);\n\n    break;\n  }\n\n  /*    $db version\n  **\n  ** Return the version string for this database.\n  */\n  case DB_VERSION: {\n    Tcl_SetResult(interp, (char *)sqlite3_libversion(), TCL_STATIC);\n    break;\n  }\n\n\n  } /* End of the SWITCH statement */\n  return rc;\n}\n\n#if SQLITE_TCL_NRE\n/*\n** Adaptor that provides an objCmd interface to the NRE-enabled\n** interface implementation.\n*/\nstatic int DbObjCmdAdaptor(\n  void *cd,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *const*objv\n){\n  return Tcl_NRCallObjProc(interp, DbObjCmd, cd, objc, objv);\n}\n#endif /* SQLITE_TCL_NRE */\n\n/*\n**   sqlite3 DBNAME FILENAME ?-vfs VFSNAME? ?-key KEY? ?-readonly BOOLEAN?\n**                           ?-create BOOLEAN? ?-nomutex BOOLEAN?\n**\n** This is the main Tcl command.  When the \"sqlite\" Tcl command is\n** invoked, this routine runs to process that command.\n**\n** The first argument, DBNAME, is an arbitrary name for a new\n** database connection.  This command creates a new command named\n** DBNAME that is used to control that connection.  The database\n** connection is deleted when the DBNAME command is deleted.\n**\n** The second argument is the name of the database file.\n**\n*/\nstatic int DbMain(void *cd, Tcl_Interp *interp, int objc,Tcl_Obj *const*objv){\n  SqliteDb *p;\n  const char *zArg;\n  char *zErrMsg;\n  int i;\n  const char *zFile;\n  const char *zVfs = 0;\n  int flags;\n  Tcl_DString translatedFilename;\n#ifdef SQLITE_HAS_CODEC\n  void *pKey = 0;\n  int nKey = 0;\n#endif\n  int rc;\n\n  /* In normal use, each TCL interpreter runs in a single thread.  So\n  ** by default, we can turn of mutexing on SQLite database connections.\n  ** However, for testing purposes it is useful to have mutexes turned\n  ** on.  So, by default, mutexes default off.  But if compiled with\n  ** SQLITE_TCL_DEFAULT_FULLMUTEX then mutexes default on.\n  */\n#ifdef SQLITE_TCL_DEFAULT_FULLMUTEX\n  flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX;\n#else\n  flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_NOMUTEX;\n#endif\n\n  if( objc==2 ){\n    zArg = Tcl_GetStringFromObj(objv[1], 0);\n    if( strcmp(zArg,\"-version\")==0 ){\n      Tcl_AppendResult(interp,sqlite3_version,0);\n      return TCL_OK;\n    }\n    if( strcmp(zArg,\"-has-codec\")==0 ){\n#ifdef SQLITE_HAS_CODEC\n      Tcl_AppendResult(interp,\"1\",0);\n#else\n      Tcl_AppendResult(interp,\"0\",0);\n#endif\n      return TCL_OK;\n    }\n  }\n  for(i=3; i+1<objc; i+=2){\n    zArg = Tcl_GetString(objv[i]);\n    if( strcmp(zArg,\"-key\")==0 ){\n#ifdef SQLITE_HAS_CODEC\n      pKey = Tcl_GetByteArrayFromObj(objv[i+1], &nKey);\n#endif\n    }else if( strcmp(zArg, \"-vfs\")==0 ){\n      zVfs = Tcl_GetString(objv[i+1]);\n    }else if( strcmp(zArg, \"-readonly\")==0 ){\n      int b;\n      if( Tcl_GetBooleanFromObj(interp, objv[i+1], &b) ) return TCL_ERROR;\n      if( b ){\n        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);\n        flags |= SQLITE_OPEN_READONLY;\n      }else{\n        flags &= ~SQLITE_OPEN_READONLY;\n        flags |= SQLITE_OPEN_READWRITE;\n      }\n    }else if( strcmp(zArg, \"-create\")==0 ){\n      int b;\n      if( Tcl_GetBooleanFromObj(interp, objv[i+1], &b) ) return TCL_ERROR;\n      if( b && (flags & SQLITE_OPEN_READONLY)==0 ){\n        flags |= SQLITE_OPEN_CREATE;\n      }else{\n        flags &= ~SQLITE_OPEN_CREATE;\n      }\n    }else if( strcmp(zArg, \"-nomutex\")==0 ){\n      int b;\n      if( Tcl_GetBooleanFromObj(interp, objv[i+1], &b) ) return TCL_ERROR;\n      if( b ){\n        flags |= SQLITE_OPEN_NOMUTEX;\n        flags &= ~SQLITE_OPEN_FULLMUTEX;\n      }else{\n        flags &= ~SQLITE_OPEN_NOMUTEX;\n      }\n    }else if( strcmp(zArg, \"-fullmutex\")==0 ){\n      int b;\n      if( Tcl_GetBooleanFromObj(interp, objv[i+1], &b) ) return TCL_ERROR;\n      if( b ){\n        flags |= SQLITE_OPEN_FULLMUTEX;\n        flags &= ~SQLITE_OPEN_NOMUTEX;\n      }else{\n        flags &= ~SQLITE_OPEN_FULLMUTEX;\n      }\n    }else if( strcmp(zArg, \"-uri\")==0 ){\n      int b;\n      if( Tcl_GetBooleanFromObj(interp, objv[i+1], &b) ) return TCL_ERROR;\n      if( b ){\n        flags |= SQLITE_OPEN_URI;\n      }else{\n        flags &= ~SQLITE_OPEN_URI;\n      }\n    }else{\n      Tcl_AppendResult(interp, \"unknown option: \", zArg, (char*)0);\n      return TCL_ERROR;\n    }\n  }\n  if( objc<3 || (objc&1)!=1 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \n      \"HANDLE FILENAME ?-vfs VFSNAME? ?-readonly BOOLEAN? ?-create BOOLEAN?\"\n      \" ?-nomutex BOOLEAN? ?-fullmutex BOOLEAN? ?-uri BOOLEAN?\"\n#ifdef SQLITE_HAS_CODEC\n      \" ?-key CODECKEY?\"\n#endif\n    );\n    return TCL_ERROR;\n  }\n  zErrMsg = 0;\n  p = (SqliteDb*)Tcl_Alloc( sizeof(*p) );\n  if( p==0 ){\n    Tcl_SetResult(interp, \"malloc failed\", TCL_STATIC);\n    return TCL_ERROR;\n  }\n  memset(p, 0, sizeof(*p));\n  zFile = Tcl_GetStringFromObj(objv[2], 0);\n  zFile = Tcl_TranslateFileName(interp, zFile, &translatedFilename);\n  rc = sqlite3_open_v2(zFile, &p->db, flags, zVfs);\n  Tcl_DStringFree(&translatedFilename);\n  if( p->db ){\n    if( SQLITE_OK!=sqlite3_errcode(p->db) ){\n      zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(p->db));\n      sqlite3_close(p->db);\n      p->db = 0;\n    }\n  }else{\n    zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errstr(rc));\n  }\n#ifdef SQLITE_HAS_CODEC\n  if( p->db ){\n    sqlite3_key(p->db, pKey, nKey);\n  }\n#endif\n  if( p->db==0 ){\n    Tcl_SetResult(interp, zErrMsg, TCL_VOLATILE);\n    Tcl_Free((char*)p);\n    sqlite3_free(zErrMsg);\n    return TCL_ERROR;\n  }\n  p->maxStmt = NUM_PREPARED_STMTS;\n  p->interp = interp;\n  zArg = Tcl_GetStringFromObj(objv[1], 0);\n  if( DbUseNre() ){\n    Tcl_NRCreateCommand(interp, zArg, DbObjCmdAdaptor, DbObjCmd,\n                        (char*)p, DbDeleteCmd);\n  }else{\n    Tcl_CreateObjCommand(interp, zArg, DbObjCmd, (char*)p, DbDeleteCmd);\n  }\n  return TCL_OK;\n}\n\n/*\n** Provide a dummy Tcl_InitStubs if we are using this as a static\n** library.\n*/\n#ifndef USE_TCL_STUBS\n# undef  Tcl_InitStubs\n# define Tcl_InitStubs(a,b,c)\n#endif\n\n/*\n** Make sure we have a PACKAGE_VERSION macro defined.  This will be\n** defined automatically by the TEA makefile.  But other makefiles\n** do not define it.\n*/\n#ifndef PACKAGE_VERSION\n# define PACKAGE_VERSION SQLITE_VERSION\n#endif\n\n/*\n** Initialize this module.\n**\n** This Tcl module contains only a single new Tcl command named \"sqlite\".\n** (Hence there is no namespace.  There is no point in using a namespace\n** if the extension only supplies one new name!)  The \"sqlite\" command is\n** used to open a new SQLite database.  See the DbMain() routine above\n** for additional information.\n**\n** The EXTERN macros are required by TCL in order to work on windows.\n*/\nEXTERN int Sqlite3_Init(Tcl_Interp *interp){\n  Tcl_InitStubs(interp, \"8.4\", 0);\n  Tcl_CreateObjCommand(interp, \"sqlite3\", (Tcl_ObjCmdProc*)DbMain, 0, 0);\n  Tcl_PkgProvide(interp, \"sqlite3\", PACKAGE_VERSION);\n\n#ifndef SQLITE_3_SUFFIX_ONLY\n  /* The \"sqlite\" alias is undocumented.  It is here only to support\n  ** legacy scripts.  All new scripts should use only the \"sqlite3\"\n  ** command.\n  */\n  Tcl_CreateObjCommand(interp, \"sqlite\", (Tcl_ObjCmdProc*)DbMain, 0, 0);\n#endif\n\n  return TCL_OK;\n}\nEXTERN int Tclsqlite3_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }\nEXTERN int Sqlite3_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }\nEXTERN int Tclsqlite3_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }\n\n/* Because it accesses the file-system and uses persistent state, SQLite\n** is not considered appropriate for safe interpreters.  Hence, we deliberately\n** omit the _SafeInit() interfaces.\n*/\n\n#ifndef SQLITE_3_SUFFIX_ONLY\nint Sqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }\nint Tclsqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }\nint Sqlite_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }\nint Tclsqlite_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }\n#endif\n\n#ifdef TCLSH\n/*****************************************************************************\n** All of the code that follows is used to build standalone TCL interpreters\n** that are statically linked with SQLite.  Enable these by compiling\n** with -DTCLSH=n where n can be 1 or 2.  An n of 1 generates a standard\n** tclsh but with SQLite built in.  An n of 2 generates the SQLite space\n** analysis program.\n*/\n\n#if defined(SQLITE_TEST) || defined(SQLITE_TCLMD5)\n/*\n * This code implements the MD5 message-digest algorithm.\n * The algorithm is due to Ron Rivest.  This code was\n * written by Colin Plumb in 1993, no copyright is claimed.\n * This code is in the public domain; do with it what you wish.\n *\n * Equivalent code is available from RSA Data Security, Inc.\n * This code has been tested against that, and is equivalent,\n * except that you don't need to include two pages of legalese\n * with every copy.\n *\n * To compute the message digest of a chunk of bytes, declare an\n * MD5Context structure, pass it to MD5Init, call MD5Update as\n * needed on buffers full of bytes, and then call MD5Final, which\n * will fill a supplied 16-byte array with the digest.\n */\n\n/*\n * If compiled on a machine that doesn't have a 32-bit integer,\n * you just set \"uint32\" to the appropriate datatype for an\n * unsigned 32-bit integer.  For example:\n *\n *       cc -Duint32='unsigned long' md5.c\n *\n */\n#ifndef uint32\n#  define uint32 unsigned int\n#endif\n\nstruct MD5Context {\n  int isInit;\n  uint32 buf[4];\n  uint32 bits[2];\n  unsigned char in[64];\n};\ntypedef struct MD5Context MD5Context;\n\n/*\n * Note: this code is harmless on little-endian machines.\n */\nstatic void byteReverse (unsigned char *buf, unsigned longs){\n        uint32 t;\n        do {\n                t = (uint32)((unsigned)buf[3]<<8 | buf[2]) << 16 |\n                            ((unsigned)buf[1]<<8 | buf[0]);\n                *(uint32 *)buf = t;\n                buf += 4;\n        } while (--longs);\n}\n/* The four core functions - F1 is optimized somewhat */\n\n/* #define F1(x, y, z) (x & y | ~x & z) */\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n/* This is the central step in the MD5 algorithm. */\n#define MD5STEP(f, w, x, y, z, data, s) \\\n        ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )\n\n/*\n * The core of the MD5 algorithm, this alters an existing MD5 hash to\n * reflect the addition of 16 longwords of new data.  MD5Update blocks\n * the data and converts bytes into longwords for this routine.\n */\nstatic void MD5Transform(uint32 buf[4], const uint32 in[16]){\n        register uint32 a, b, c, d;\n\n        a = buf[0];\n        b = buf[1];\n        c = buf[2];\n        d = buf[3];\n\n        MD5STEP(F1, a, b, c, d, in[ 0]+0xd76aa478,  7);\n        MD5STEP(F1, d, a, b, c, in[ 1]+0xe8c7b756, 12);\n        MD5STEP(F1, c, d, a, b, in[ 2]+0x242070db, 17);\n        MD5STEP(F1, b, c, d, a, in[ 3]+0xc1bdceee, 22);\n        MD5STEP(F1, a, b, c, d, in[ 4]+0xf57c0faf,  7);\n        MD5STEP(F1, d, a, b, c, in[ 5]+0x4787c62a, 12);\n        MD5STEP(F1, c, d, a, b, in[ 6]+0xa8304613, 17);\n        MD5STEP(F1, b, c, d, a, in[ 7]+0xfd469501, 22);\n        MD5STEP(F1, a, b, c, d, in[ 8]+0x698098d8,  7);\n        MD5STEP(F1, d, a, b, c, in[ 9]+0x8b44f7af, 12);\n        MD5STEP(F1, c, d, a, b, in[10]+0xffff5bb1, 17);\n        MD5STEP(F1, b, c, d, a, in[11]+0x895cd7be, 22);\n        MD5STEP(F1, a, b, c, d, in[12]+0x6b901122,  7);\n        MD5STEP(F1, d, a, b, c, in[13]+0xfd987193, 12);\n        MD5STEP(F1, c, d, a, b, in[14]+0xa679438e, 17);\n        MD5STEP(F1, b, c, d, a, in[15]+0x49b40821, 22);\n\n        MD5STEP(F2, a, b, c, d, in[ 1]+0xf61e2562,  5);\n        MD5STEP(F2, d, a, b, c, in[ 6]+0xc040b340,  9);\n        MD5STEP(F2, c, d, a, b, in[11]+0x265e5a51, 14);\n        MD5STEP(F2, b, c, d, a, in[ 0]+0xe9b6c7aa, 20);\n        MD5STEP(F2, a, b, c, d, in[ 5]+0xd62f105d,  5);\n        MD5STEP(F2, d, a, b, c, in[10]+0x02441453,  9);\n        MD5STEP(F2, c, d, a, b, in[15]+0xd8a1e681, 14);\n        MD5STEP(F2, b, c, d, a, in[ 4]+0xe7d3fbc8, 20);\n        MD5STEP(F2, a, b, c, d, in[ 9]+0x21e1cde6,  5);\n        MD5STEP(F2, d, a, b, c, in[14]+0xc33707d6,  9);\n        MD5STEP(F2, c, d, a, b, in[ 3]+0xf4d50d87, 14);\n        MD5STEP(F2, b, c, d, a, in[ 8]+0x455a14ed, 20);\n        MD5STEP(F2, a, b, c, d, in[13]+0xa9e3e905,  5);\n        MD5STEP(F2, d, a, b, c, in[ 2]+0xfcefa3f8,  9);\n        MD5STEP(F2, c, d, a, b, in[ 7]+0x676f02d9, 14);\n        MD5STEP(F2, b, c, d, a, in[12]+0x8d2a4c8a, 20);\n\n        MD5STEP(F3, a, b, c, d, in[ 5]+0xfffa3942,  4);\n        MD5STEP(F3, d, a, b, c, in[ 8]+0x8771f681, 11);\n        MD5STEP(F3, c, d, a, b, in[11]+0x6d9d6122, 16);\n        MD5STEP(F3, b, c, d, a, in[14]+0xfde5380c, 23);\n        MD5STEP(F3, a, b, c, d, in[ 1]+0xa4beea44,  4);\n        MD5STEP(F3, d, a, b, c, in[ 4]+0x4bdecfa9, 11);\n        MD5STEP(F3, c, d, a, b, in[ 7]+0xf6bb4b60, 16);\n        MD5STEP(F3, b, c, d, a, in[10]+0xbebfbc70, 23);\n        MD5STEP(F3, a, b, c, d, in[13]+0x289b7ec6,  4);\n        MD5STEP(F3, d, a, b, c, in[ 0]+0xeaa127fa, 11);\n        MD5STEP(F3, c, d, a, b, in[ 3]+0xd4ef3085, 16);\n        MD5STEP(F3, b, c, d, a, in[ 6]+0x04881d05, 23);\n        MD5STEP(F3, a, b, c, d, in[ 9]+0xd9d4d039,  4);\n        MD5STEP(F3, d, a, b, c, in[12]+0xe6db99e5, 11);\n        MD5STEP(F3, c, d, a, b, in[15]+0x1fa27cf8, 16);\n        MD5STEP(F3, b, c, d, a, in[ 2]+0xc4ac5665, 23);\n\n        MD5STEP(F4, a, b, c, d, in[ 0]+0xf4292244,  6);\n        MD5STEP(F4, d, a, b, c, in[ 7]+0x432aff97, 10);\n        MD5STEP(F4, c, d, a, b, in[14]+0xab9423a7, 15);\n        MD5STEP(F4, b, c, d, a, in[ 5]+0xfc93a039, 21);\n        MD5STEP(F4, a, b, c, d, in[12]+0x655b59c3,  6);\n        MD5STEP(F4, d, a, b, c, in[ 3]+0x8f0ccc92, 10);\n        MD5STEP(F4, c, d, a, b, in[10]+0xffeff47d, 15);\n        MD5STEP(F4, b, c, d, a, in[ 1]+0x85845dd1, 21);\n        MD5STEP(F4, a, b, c, d, in[ 8]+0x6fa87e4f,  6);\n        MD5STEP(F4, d, a, b, c, in[15]+0xfe2ce6e0, 10);\n        MD5STEP(F4, c, d, a, b, in[ 6]+0xa3014314, 15);\n        MD5STEP(F4, b, c, d, a, in[13]+0x4e0811a1, 21);\n        MD5STEP(F4, a, b, c, d, in[ 4]+0xf7537e82,  6);\n        MD5STEP(F4, d, a, b, c, in[11]+0xbd3af235, 10);\n        MD5STEP(F4, c, d, a, b, in[ 2]+0x2ad7d2bb, 15);\n        MD5STEP(F4, b, c, d, a, in[ 9]+0xeb86d391, 21);\n\n        buf[0] += a;\n        buf[1] += b;\n        buf[2] += c;\n        buf[3] += d;\n}\n\n/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\nstatic void MD5Init(MD5Context *ctx){\n        ctx->isInit = 1;\n        ctx->buf[0] = 0x67452301;\n        ctx->buf[1] = 0xefcdab89;\n        ctx->buf[2] = 0x98badcfe;\n        ctx->buf[3] = 0x10325476;\n        ctx->bits[0] = 0;\n        ctx->bits[1] = 0;\n}\n\n/*\n * Update context to reflect the concatenation of another buffer full\n * of bytes.\n */\nstatic \nvoid MD5Update(MD5Context *ctx, const unsigned char *buf, unsigned int len){\n        uint32 t;\n\n        /* Update bitcount */\n\n        t = ctx->bits[0];\n        if ((ctx->bits[0] = t + ((uint32)len << 3)) < t)\n                ctx->bits[1]++; /* Carry from low to high */\n        ctx->bits[1] += len >> 29;\n\n        t = (t >> 3) & 0x3f;    /* Bytes already in shsInfo->data */\n\n        /* Handle any leading odd-sized chunks */\n\n        if ( t ) {\n                unsigned char *p = (unsigned char *)ctx->in + t;\n\n                t = 64-t;\n                if (len < t) {\n                        memcpy(p, buf, len);\n                        return;\n                }\n                memcpy(p, buf, t);\n                byteReverse(ctx->in, 16);\n                MD5Transform(ctx->buf, (uint32 *)ctx->in);\n                buf += t;\n                len -= t;\n        }\n\n        /* Process data in 64-byte chunks */\n\n        while (len >= 64) {\n                memcpy(ctx->in, buf, 64);\n                byteReverse(ctx->in, 16);\n                MD5Transform(ctx->buf, (uint32 *)ctx->in);\n                buf += 64;\n                len -= 64;\n        }\n\n        /* Handle any remaining bytes of data. */\n\n        memcpy(ctx->in, buf, len);\n}\n\n/*\n * Final wrapup - pad to 64-byte boundary with the bit pattern \n * 1 0* (64-bit count of bits processed, MSB-first)\n */\nstatic void MD5Final(unsigned char digest[16], MD5Context *ctx){\n        unsigned count;\n        unsigned char *p;\n\n        /* Compute number of bytes mod 64 */\n        count = (ctx->bits[0] >> 3) & 0x3F;\n\n        /* Set the first char of padding to 0x80.  This is safe since there is\n           always at least one byte free */\n        p = ctx->in + count;\n        *p++ = 0x80;\n\n        /* Bytes of padding needed to make 64 bytes */\n        count = 64 - 1 - count;\n\n        /* Pad out to 56 mod 64 */\n        if (count < 8) {\n                /* Two lots of padding:  Pad the first block to 64 bytes */\n                memset(p, 0, count);\n                byteReverse(ctx->in, 16);\n                MD5Transform(ctx->buf, (uint32 *)ctx->in);\n\n                /* Now fill the next block with 56 bytes */\n                memset(ctx->in, 0, 56);\n        } else {\n                /* Pad block to 56 bytes */\n                memset(p, 0, count-8);\n        }\n        byteReverse(ctx->in, 14);\n\n        /* Append length in bits and transform */\n        ((uint32 *)ctx->in)[ 14 ] = ctx->bits[0];\n        ((uint32 *)ctx->in)[ 15 ] = ctx->bits[1];\n\n        MD5Transform(ctx->buf, (uint32 *)ctx->in);\n        byteReverse((unsigned char *)ctx->buf, 4);\n        memcpy(digest, ctx->buf, 16);\n        memset(ctx, 0, sizeof(ctx));    /* In case it is sensitive */\n}\n\n/*\n** Convert a 128-bit MD5 digest into a 32-digit base-16 number.\n*/\nstatic void MD5DigestToBase16(unsigned char *digest, char *zBuf){\n  static char const zEncode[] = \"0123456789abcdef\";\n  int i, j;\n\n  for(j=i=0; i<16; i++){\n    int a = digest[i];\n    zBuf[j++] = zEncode[(a>>4)&0xf];\n    zBuf[j++] = zEncode[a & 0xf];\n  }\n  zBuf[j] = 0;\n}\n\n\n/*\n** Convert a 128-bit MD5 digest into sequency of eight 5-digit integers\n** each representing 16 bits of the digest and separated from each\n** other by a \"-\" character.\n*/\nstatic void MD5DigestToBase10x8(unsigned char digest[16], char zDigest[50]){\n  int i, j;\n  unsigned int x;\n  for(i=j=0; i<16; i+=2){\n    x = digest[i]*256 + digest[i+1];\n    if( i>0 ) zDigest[j++] = '-';\n    sprintf(&zDigest[j], \"%05u\", x);\n    j += 5;\n  }\n  zDigest[j] = 0;\n}\n\n/*\n** A TCL command for md5.  The argument is the text to be hashed.  The\n** Result is the hash in base64.  \n*/\nstatic int md5_cmd(void*cd, Tcl_Interp *interp, int argc, const char **argv){\n  MD5Context ctx;\n  unsigned char digest[16];\n  char zBuf[50];\n  void (*converter)(unsigned char*, char*);\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp,\"wrong # args: should be \\\"\", argv[0], \n        \" TEXT\\\"\", 0);\n    return TCL_ERROR;\n  }\n  MD5Init(&ctx);\n  MD5Update(&ctx, (unsigned char*)argv[1], (unsigned)strlen(argv[1]));\n  MD5Final(digest, &ctx);\n  converter = (void(*)(unsigned char*,char*))cd;\n  converter(digest, zBuf);\n  Tcl_AppendResult(interp, zBuf, (char*)0);\n  return TCL_OK;\n}\n\n/*\n** A TCL command to take the md5 hash of a file.  The argument is the\n** name of the file.\n*/\nstatic int md5file_cmd(void*cd, Tcl_Interp*interp, int argc, const char **argv){\n  FILE *in;\n  MD5Context ctx;\n  void (*converter)(unsigned char*, char*);\n  unsigned char digest[16];\n  char zBuf[10240];\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp,\"wrong # args: should be \\\"\", argv[0], \n        \" FILENAME\\\"\", 0);\n    return TCL_ERROR;\n  }\n  in = fopen(argv[1],\"rb\");\n  if( in==0 ){\n    Tcl_AppendResult(interp,\"unable to open file \\\"\", argv[1], \n         \"\\\" for reading\", 0);\n    return TCL_ERROR;\n  }\n  MD5Init(&ctx);\n  for(;;){\n    int n;\n    n = (int)fread(zBuf, 1, sizeof(zBuf), in);\n    if( n<=0 ) break;\n    MD5Update(&ctx, (unsigned char*)zBuf, (unsigned)n);\n  }\n  fclose(in);\n  MD5Final(digest, &ctx);\n  converter = (void(*)(unsigned char*,char*))cd;\n  converter(digest, zBuf);\n  Tcl_AppendResult(interp, zBuf, (char*)0);\n  return TCL_OK;\n}\n\n/*\n** Register the four new TCL commands for generating MD5 checksums\n** with the TCL interpreter.\n*/\nint Md5_Init(Tcl_Interp *interp){\n  Tcl_CreateCommand(interp, \"md5\", (Tcl_CmdProc*)md5_cmd,\n                    MD5DigestToBase16, 0);\n  Tcl_CreateCommand(interp, \"md5-10x8\", (Tcl_CmdProc*)md5_cmd,\n                    MD5DigestToBase10x8, 0);\n  Tcl_CreateCommand(interp, \"md5file\", (Tcl_CmdProc*)md5file_cmd,\n                    MD5DigestToBase16, 0);\n  Tcl_CreateCommand(interp, \"md5file-10x8\", (Tcl_CmdProc*)md5file_cmd,\n                    MD5DigestToBase10x8, 0);\n  return TCL_OK;\n}\n#endif /* defined(SQLITE_TEST) || defined(SQLITE_TCLMD5) */\n\n#if defined(SQLITE_TEST)\n/*\n** During testing, the special md5sum() aggregate function is available.\n** inside SQLite.  The following routines implement that function.\n*/\nstatic void md5step(sqlite3_context *context, int argc, sqlite3_value **argv){\n  MD5Context *p;\n  int i;\n  if( argc<1 ) return;\n  p = sqlite3_aggregate_context(context, sizeof(*p));\n  if( p==0 ) return;\n  if( !p->isInit ){\n    MD5Init(p);\n  }\n  for(i=0; i<argc; i++){\n    const char *zData = (char*)sqlite3_value_text(argv[i]);\n    if( zData ){\n      MD5Update(p, (unsigned char*)zData, (int)strlen(zData));\n    }\n  }\n}\nstatic void md5finalize(sqlite3_context *context){\n  MD5Context *p;\n  unsigned char digest[16];\n  char zBuf[33];\n  p = sqlite3_aggregate_context(context, sizeof(*p));\n  MD5Final(digest,p);\n  MD5DigestToBase16(digest, zBuf);\n  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);\n}\nint Md5_Register(sqlite3 *db){\n  int rc = sqlite3_create_function(db, \"md5sum\", -1, SQLITE_UTF8, 0, 0, \n                                 md5step, md5finalize);\n  sqlite3_overload_function(db, \"md5sum\", -1);  /* To exercise this API */\n  return rc;\n}\n#endif /* defined(SQLITE_TEST) */\n\n\n/*\n** If the macro TCLSH is one, then put in code this for the\n** \"main\" routine that will initialize Tcl and take input from\n** standard input, or if a file is named on the command line\n** the TCL interpreter reads and evaluates that file.\n*/\n#if TCLSH==1\nstatic const char *tclsh_main_loop(void){\n  static const char zMainloop[] =\n    \"set line {}\\n\"\n    \"while {![eof stdin]} {\\n\"\n      \"if {$line!=\\\"\\\"} {\\n\"\n        \"puts -nonewline \\\"> \\\"\\n\"\n      \"} else {\\n\"\n        \"puts -nonewline \\\"% \\\"\\n\"\n      \"}\\n\"\n      \"flush stdout\\n\"\n      \"append line [gets stdin]\\n\"\n      \"if {[info complete $line]} {\\n\"\n        \"if {[catch {uplevel #0 $line} result]} {\\n\"\n          \"puts stderr \\\"Error: $result\\\"\\n\"\n        \"} elseif {$result!=\\\"\\\"} {\\n\"\n          \"puts $result\\n\"\n        \"}\\n\"\n        \"set line {}\\n\"\n      \"} else {\\n\"\n        \"append line \\\\n\\n\"\n      \"}\\n\"\n    \"}\\n\"\n  ;\n  return zMainloop;\n}\n#endif\n#if TCLSH==2\nstatic const char *tclsh_main_loop(void);\n#endif\n\n#ifdef SQLITE_TEST\nstatic void init_all(Tcl_Interp *);\nstatic int init_all_cmd(\n  ClientData cd,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n\n  Tcl_Interp *slave;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"SLAVE\");\n    return TCL_ERROR;\n  }\n\n  slave = Tcl_GetSlave(interp, Tcl_GetString(objv[1]));\n  if( !slave ){\n    return TCL_ERROR;\n  }\n\n  init_all(slave);\n  return TCL_OK;\n}\n\n/*\n** Tclcmd: db_use_legacy_prepare DB BOOLEAN\n**\n**   The first argument to this command must be a database command created by\n**   [sqlite3]. If the second argument is true, then the handle is configured\n**   to use the sqlite3_prepare_v2() function to prepare statements. If it\n**   is false, sqlite3_prepare().\n*/\nstatic int db_use_legacy_prepare_cmd(\n  ClientData cd,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  Tcl_CmdInfo cmdInfo;\n  SqliteDb *pDb;\n  int bPrepare;\n\n  if( objc!=3 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"DB BOOLEAN\");\n    return TCL_ERROR;\n  }\n\n  if( !Tcl_GetCommandInfo(interp, Tcl_GetString(objv[1]), &cmdInfo) ){\n    Tcl_AppendResult(interp, \"no such db: \", Tcl_GetString(objv[1]), (char*)0);\n    return TCL_ERROR;\n  }\n  pDb = (SqliteDb*)cmdInfo.objClientData;\n  if( Tcl_GetBooleanFromObj(interp, objv[2], &bPrepare) ){\n    return TCL_ERROR;\n  }\n\n  pDb->bLegacyPrepare = bPrepare;\n\n  Tcl_ResetResult(interp);\n  return TCL_OK;\n}\n#endif\n\n/*\n** Configure the interpreter passed as the first argument to have access\n** to the commands and linked variables that make up:\n**\n**   * the [sqlite3] extension itself, \n**\n**   * If SQLITE_TCLMD5 or SQLITE_TEST is defined, the Md5 commands, and\n**\n**   * If SQLITE_TEST is set, the various test interfaces used by the Tcl\n**     test suite.\n*/\nstatic void init_all(Tcl_Interp *interp){\n  Sqlite3_Init(interp);\n\n#if defined(SQLITE_TEST) || defined(SQLITE_TCLMD5)\n  Md5_Init(interp);\n#endif\n\n  /* Install the [register_dbstat_vtab] command to access the implementation\n  ** of virtual table dbstat (source file test_stat.c). This command is\n  ** required for testfixture and sqlite3_analyzer, but not by the production\n  ** Tcl extension.  */\n#if defined(SQLITE_TEST) || TCLSH==2\n  {\n    extern int SqlitetestStat_Init(Tcl_Interp*);\n    SqlitetestStat_Init(interp);\n  }\n#endif\n\n#ifdef SQLITE_TEST\n  {\n    extern int Sqliteconfig_Init(Tcl_Interp*);\n    extern int Sqlitetest1_Init(Tcl_Interp*);\n    extern int Sqlitetest2_Init(Tcl_Interp*);\n    extern int Sqlitetest3_Init(Tcl_Interp*);\n    extern int Sqlitetest4_Init(Tcl_Interp*);\n    extern int Sqlitetest5_Init(Tcl_Interp*);\n    extern int Sqlitetest6_Init(Tcl_Interp*);\n    extern int Sqlitetest7_Init(Tcl_Interp*);\n    extern int Sqlitetest8_Init(Tcl_Interp*);\n    extern int Sqlitetest9_Init(Tcl_Interp*);\n    extern int Sqlitetestasync_Init(Tcl_Interp*);\n    extern int Sqlitetest_autoext_Init(Tcl_Interp*);\n    extern int Sqlitetest_demovfs_Init(Tcl_Interp *);\n    extern int Sqlitetest_func_Init(Tcl_Interp*);\n    extern int Sqlitetest_hexio_Init(Tcl_Interp*);\n    extern int Sqlitetest_init_Init(Tcl_Interp*);\n    extern int Sqlitetest_malloc_Init(Tcl_Interp*);\n    extern int Sqlitetest_mutex_Init(Tcl_Interp*);\n    extern int Sqlitetestschema_Init(Tcl_Interp*);\n    extern int Sqlitetestsse_Init(Tcl_Interp*);\n    extern int Sqlitetesttclvar_Init(Tcl_Interp*);\n    extern int Sqlitetestfs_Init(Tcl_Interp*);\n    extern int SqlitetestThread_Init(Tcl_Interp*);\n    extern int SqlitetestOnefile_Init();\n    extern int SqlitetestOsinst_Init(Tcl_Interp*);\n    extern int Sqlitetestbackup_Init(Tcl_Interp*);\n    extern int Sqlitetestintarray_Init(Tcl_Interp*);\n    extern int Sqlitetestvfs_Init(Tcl_Interp *);\n    extern int Sqlitetestrtree_Init(Tcl_Interp*);\n    extern int Sqlitequota_Init(Tcl_Interp*);\n    extern int Sqlitemultiplex_Init(Tcl_Interp*);\n    extern int SqliteSuperlock_Init(Tcl_Interp*);\n    extern int SqlitetestSyscall_Init(Tcl_Interp*);\n\n#if defined(SQLITE_ENABLE_FTS3) || defined(SQLITE_ENABLE_FTS4)\n    extern int Sqlitetestfts3_Init(Tcl_Interp *interp);\n#endif\n\n#ifdef SQLITE_ENABLE_ZIPVFS\n    extern int Zipvfs_Init(Tcl_Interp*);\n    Zipvfs_Init(interp);\n#endif\n\n    Sqliteconfig_Init(interp);\n    Sqlitetest1_Init(interp);\n    Sqlitetest2_Init(interp);\n    Sqlitetest3_Init(interp);\n    Sqlitetest4_Init(interp);\n    Sqlitetest5_Init(interp);\n    Sqlitetest6_Init(interp);\n    Sqlitetest7_Init(interp);\n    Sqlitetest8_Init(interp);\n    Sqlitetest9_Init(interp);\n    Sqlitetestasync_Init(interp);\n    Sqlitetest_autoext_Init(interp);\n    Sqlitetest_demovfs_Init(interp);\n    Sqlitetest_func_Init(interp);\n    Sqlitetest_hexio_Init(interp);\n    Sqlitetest_init_Init(interp);\n    Sqlitetest_malloc_Init(interp);\n    Sqlitetest_mutex_Init(interp);\n    Sqlitetestschema_Init(interp);\n    Sqlitetesttclvar_Init(interp);\n    Sqlitetestfs_Init(interp);\n    SqlitetestThread_Init(interp);\n    SqlitetestOnefile_Init(interp);\n    SqlitetestOsinst_Init(interp);\n    Sqlitetestbackup_Init(interp);\n    Sqlitetestintarray_Init(interp);\n    Sqlitetestvfs_Init(interp);\n    Sqlitetestrtree_Init(interp);\n    Sqlitequota_Init(interp);\n    Sqlitemultiplex_Init(interp);\n    SqliteSuperlock_Init(interp);\n    SqlitetestSyscall_Init(interp);\n\n#if defined(SQLITE_ENABLE_FTS3) || defined(SQLITE_ENABLE_FTS4)\n    Sqlitetestfts3_Init(interp);\n#endif\n\n    Tcl_CreateObjCommand(\n        interp, \"load_testfixture_extensions\", init_all_cmd, 0, 0\n    );\n    Tcl_CreateObjCommand(\n        interp, \"db_use_legacy_prepare\", db_use_legacy_prepare_cmd, 0, 0\n    );\n\n#ifdef SQLITE_SSE\n    Sqlitetestsse_Init(interp);\n#endif\n  }\n#endif\n}\n\n#define TCLSH_MAIN main   /* Needed to fake out mktclapp */\nint TCLSH_MAIN(int argc, char **argv){\n  Tcl_Interp *interp;\n  \n  /* Call sqlite3_shutdown() once before doing anything else. This is to\n  ** test that sqlite3_shutdown() can be safely called by a process before\n  ** sqlite3_initialize() is. */\n  sqlite3_shutdown();\n\n  Tcl_FindExecutable(argv[0]);\n  interp = Tcl_CreateInterp();\n\n#if TCLSH==2\n  sqlite3_config(SQLITE_CONFIG_SINGLETHREAD);\n#endif\n\n  init_all(interp);\n  if( argc>=2 ){\n    int i;\n    char zArgc[32];\n    sqlite3_snprintf(sizeof(zArgc), zArgc, \"%d\", argc-(3-TCLSH));\n    Tcl_SetVar(interp,\"argc\", zArgc, TCL_GLOBAL_ONLY);\n    Tcl_SetVar(interp,\"argv0\",argv[1],TCL_GLOBAL_ONLY);\n    Tcl_SetVar(interp,\"argv\", \"\", TCL_GLOBAL_ONLY);\n    for(i=3-TCLSH; i<argc; i++){\n      Tcl_SetVar(interp, \"argv\", argv[i],\n          TCL_GLOBAL_ONLY | TCL_LIST_ELEMENT | TCL_APPEND_VALUE);\n    }\n    if( TCLSH==1 && Tcl_EvalFile(interp, argv[1])!=TCL_OK ){\n      const char *zInfo = Tcl_GetVar(interp, \"errorInfo\", TCL_GLOBAL_ONLY);\n      if( zInfo==0 ) zInfo = Tcl_GetStringResult(interp);\n      fprintf(stderr,\"%s: %s\\n\", *argv, zInfo);\n      return 1;\n    }\n  }\n  if( TCLSH==2 || argc<=1 ){\n    Tcl_GlobalEval(interp, tclsh_main_loop());\n  }\n  return 0;\n}\n#endif /* TCLSH */\n"]],"start1":0,"start2":0,"length1":0,"length2":118100}]],"length":118100}
