{"ts":1378896667023,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var PriorityQueue = function(size) {\n  var me = {}, slots, i, total = null;\n\n  // initialize arrays to hold queue elements\n  size = Math.max(+size | 0, 1);\n  slots = [];\n  for (i = 0; i < size; i += 1) {\n    slots.push([]);\n  }\n\n  //  Public methods\n  me.size = function () {\n    var i;\n    if (total === null) {\n      total = 0;\n      for (i = 0; i < size; i += 1) {\n        total += slots[i].length;\n      }\n    }\n    return total;\n  };\n\n  me.enqueue = function (obj, priority) {\n    var priorityOrig;\n\n    // Convert to integer with a default value of 0.\n    priority = priority && + priority | 0 || 0;\n\n    // Clear cache for total.\n    total = null;\n    if (priority) {\n      priorityOrig = priority;\n      if (priority < 0 || priority >= size) {\n        priority = (size - 1);\n        // put obj at the end of the line\n        console.error(\"invalid priority: \" + priorityOrig + \" must be between 0 and \" + priority);\n      }\n    }\n\n    slots[priority].push(obj);\n  };\n\n  me.dequeue = function (callback) {\n    var obj = null, i, sl = slots.length;\n\n    // Clear cache for total.\n    total = null;\n    for (i = 0; i < sl; i += 1) {\n      if (slots[i].length) {\n        obj = slots[i].shift();\n        break;\n      }\n    }\n    return obj;\n  };\n\n  return me;\n};\n\n/**\n * Generate an Object pool with a specified `factory`.\n *\n * @param {Object} factory\n *   Factory to be used for generating and destorying the items.\n * @param {String} factory.name\n *   Name of the factory. Serves only logging purposes.\n * @param {Function} factory.create\n *   Should create the item to be acquired,\n *   and call it's first callback argument with the generated item as it's argument.\n * @param {Function} factory.destroy\n *   Should gently close any resources that the item is using.\n *   Called before the items is destroyed.\n * @param {Function} factory.validate\n *   Should return true if connection is still valid and false\n *   If it should be removed from pool. Called before item is\n *   acquired from pool.\n * @param {Number} factory.max\n *   Maximum number of items that can exist at the same time.  Default: 1.\n *   Any further acquire requests will be pushed to the waiting list.\n * @param {Number} factory.min\n *   Minimum number of items in pool (including in-use). Default: 0.\n *   When the pool is created, or a resource destroyed, this minimum will\n *   be checked. If the pool resource count is below the minimum, a new\n *   resource will be created and added to the pool.\n * @param {Number} factory.idleTimeoutMillis\n *   Delay in milliseconds after the idle items in the pool will be destroyed.\n *   And idle item is that is not acquired yet. Waiting items doesn't count here.\n * @param {Number} factory.reapIntervalMillis\n *   Cleanup is scheduled in every `factory.reapIntervalMillis` milliseconds.\n * @param {Boolean|Function} factory.log\n *   Whether the pool should log activity. If function is specified,\n *   that will be used instead. The function expects the arguments msg, loglevel\n * @param {Number} factory.priorityRange\n *   The range from 1 to be treated as a valid priority\n * @param {RefreshIdle} factory.refreshIdle\n *   Should idle resources be destroyed and recreated every idleTimeoutMillis? Default: true.\n * @returns {Object} An Object pool that works with the supplied `factory`.\n */\nexports.Pool = function (factory) {\n  var me = {},\n\n      idleTimeoutMillis = factory.idleTimeoutMillis || 30000,\n      reapInterval = factory.reapIntervalMillis || 1000,\n      refreshIdle = ('refreshIdle' in factory) ? factory.refreshIdle : true,\n      availableObjects = [],\n      waitingClients = new PriorityQueue(factory.priorityRange || 1),\n      count = 0,\n      removeIdleScheduled = false,\n      removeIdleTimer = null,\n      draining = false,\n\n      // Prepare a logger function.\n      log = factory.log ?\n        (function (str, level) {\n           if (typeof factory.log === 'function') {\n             factory.log(str, level);\n           }\n           else {\n             console.log(level.toUpperCase() + \" pool \" + factory.name + \" - \" + str);\n           }\n         }\n        ) :\n        function () {};\n\n  factory.validate = factory.validate || function() { return true; };\n        \n  factory.max = parseInt(factory.max, 10);\n  factory.min = parseInt(factory.min, 10);\n  \n  factory.max = Math.max(isNaN(factory.max) ? 1 : factory.max, 1);\n  factory.min = Math.min(isNaN(factory.min) ? 0 : factory.min, factory.max-1);\n  \n  ///////////////\n\n  /**\n   * Request the client to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} obj\n   *   The acquired item to be destoyed.\n   */\n  me.destroy = function(obj) {\n    count -= 1;\n    availableObjects = availableObjects.filter(function(objWithTimeout) {\n              return (objWithTimeout.obj !== obj);\n    });\n    factory.destroy(obj);\n    \n    ensureMinimum();\n  };\n\n  /**\n   * Checks and removes the available (idle) clients that have timed out.\n   */\n  function removeIdle() {\n    var toRemove = [],\n        now = new Date().getTime(),\n        i,\n        al, tr,\n        timeout;\n\n    removeIdleScheduled = false;\n\n    // Go through the available (idle) items,\n    // check if they have timed out\n    for (i = 0, al = availableObjects.length; i < al && (refreshIdle || (count - factory.min > toRemove.length)); i += 1) {\n      timeout = availableObjects[i].timeout;\n      if (now >= timeout) {\n        // Client timed out, so destroy it.\n        log(\"removeIdle() destroying obj - now:\" + now + \" timeout:\" + timeout, 'verbose');\n        toRemove.push(availableObjects[i].obj);\n      } \n    }\n\n    for (i = 0, tr = toRemove.length; i < tr; i += 1) {\n      me.destroy(toRemove[i]);\n    }\n\n    // Replace the available items with the ones to keep.\n    al = availableObjects.length;\n\n    if (al > 0) {\n      log(\"availableObjects.length=\" + al, 'verbose');\n      scheduleRemoveIdle();\n    } else {\n      log(\"removeIdle() all objects removed\", 'verbose');\n    }\n  }\n\n\n  /**\n   * Schedule removal of idle items in the pool.\n   *\n   * More schedules cannot run concurrently.\n   */\n  function scheduleRemoveIdle() {\n    if (!removeIdleScheduled) {\n      removeIdleScheduled = true;\n      removeIdleTimer = setTimeout(removeIdle, reapInterval);\n    }\n  }\n\n  /**\n   * Handle callbacks with either the [obj] or [err, obj] arguments in an\n   * adaptive manner. Uses the `cb.length` property to determine the number\n   * of arguments expected by `cb`.\n   */\n  function adjustCallback(cb, err, obj) {\n    if (!cb) return;\n    if (cb.length <= 1) {\n      cb(obj);\n    } else {\n      cb(err, obj);\n    }\n  }\n\n  /**\n   * Try to get a new client to work, and clean up pool unused (idle) items.\n   *\n   *  - If there are available clients waiting, shift the first one out (LIFO),\n   *    and call its callback.\n   *  - If there are no waiting clients, try to create one if it won't exceed\n   *    the maximum number of clients.\n   *  - If creating a new client would exceed the maximum, add the client to\n   *    the wait list.\n   */\n  function dispense() {\n    var obj = null,\n        objWithTimeout = null,\n        err = null,\n        clientCb = null,\n        waitingCount = waitingClients.size();\n        \n    log(\"dispense() clients=\" + waitingCount + \" available=\" + availableObjects.length, 'info');\n    if (waitingCount > 0) {\n      while (availableObjects.length > 0) {\n        log(\"dispense() - reusing obj\", 'verbose');\n        objWithTimeout = availableObjects[0];\n        if (!factory.validate(objWithTimeout.obj)) {\n          me.destroy(objWithTimeout.obj);\n          continue;\n        }\n        availableObjects.shift();\n        clientCb = waitingClients.dequeue();\n        return clientCb(err, objWithTimeout.obj);\n      }\n      if (count < factory.max) {\n        createResource();\n      }\n    }\n  }\n  \n  function createResource() {\n    count += 1;\n    log(\"createResource() - creating obj - count=\" + count + \" min=\" + factory.min + \" max=\" + factory.max, 'verbose');\n    factory.create(function () {\n      var err, obj;\n      var clientCb = waitingClients.dequeue();\n      if (arguments.length > 1) {\n        err = arguments[0];\n        obj = arguments[1];\n      } else {\n        err = (arguments[0] instanceof Error) ? arguments[0] : null;\n        obj = (arguments[0] instanceof Error) ? null : arguments[0];\n      }\n      if (err) {\n        count -= 1;\n        if (clientCb) {\n          clientCb(err, obj);\n        }\n        process.nextTick(function(){\n          dispense();\n        });\n      } else {\n        if (clientCb) {\n          clientCb(err, obj);\n        } else {\n          me.release(obj);\n        }\n      }\n    });\n  }\n  \n  function ensureMinimum() {\n    var i, diff;\n    if (!draining && (count < factory.min)) {\n      diff = factory.min - count;\n      for (i = 0; i < diff; i++) {\n        createResource();\n      }\n    }\n  }\n\n  /**\n   * Request a new client. The callback will be called,\n   * when a new client will be availabe, passing the client to it.\n   *\n   * @param {Function} callback\n   *   Callback function to be called after the acquire is successful.\n   *   The function will receive the acquired item as the first parameter.\n   *\n   * @param {Number} priority\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Object} `true` if the pool is not fully utilized, `false` otherwise.\n   */\n  me.acquire = function (callback, priority) {\n    if (draining) {\n      throw new Error(\"pool is draining and cannot accept work\");\n    }\n    waitingClients.enqueue(callback, priority);\n    dispense();\n    return (count < factory.max);\n  };\n\n  me.borrow = function (callback, priority) {\n    log(\"borrow() is deprecated. use acquire() instead\", 'warn');\n    me.acquire(callback, priority);\n  };\n\n  /**\n   * Return the client to the pool, in case it is no longer required.\n   *\n   * @param {Object} obj\n   *   The acquired object to be put back to the pool.\n   */\n  me.release = function (obj) {\n\t// check to see if this object has already been released (i.e., is back in the pool of availableObjects)\n    if (availableObjects.some(function(objWithTimeout) { return (objWithTimeout.obj === obj); })) {\n      log(\"release called twice for the same resource: \" + (new Error().stack), 'error');\n      return;\n    }\n    //log(\"return to pool\");\n    var objWithTimeout = { obj: obj, timeout: (new Date().getTime() + idleTimeoutMillis) };\n    availableObjects.push(objWithTimeout);\n    log(\"timeout: \" + objWithTimeout.timeout, 'verbose');\n    dispense();\n    scheduleRemoveIdle();\n  };\n\n  me.returnToPool = function (obj) {\n    log(\"returnToPool() is deprecated. use release() instead\", 'warn');\n    me.release(obj);\n  };\n\n  /**\n   * Disallow any new requests and let the request backlog dissapate.\n   *\n   * @param {Function} callback\n   *   Optional. Callback invoked when all work is done and all clients have been\n   *   released.\n   */\n  me.drain = function(callback) {\n    log(\"draining\", 'info');\n\n    // disable the ability to put more work on the queue.\n    draining = true;\n\n    var check = function() {\n      if (waitingClients.size() > 0) {\n        // wait until all client requests have been satisfied.\n        setTimeout(check, 100);\n      } else if (availableObjects.length != count) {\n        // wait until all objects have been released.\n        setTimeout(check, 100);\n      } else {\n        if (callback) {\n          callback();\n        }\n      }\n    };\n    check();\n  };\n\n  /**\n   * Forcibly destroys all clients regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * clients as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0, the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling destroyAllNow()\n   *\n   * @param {Function} callback\n   *   Optional. Callback invoked after all existing clients are destroyed.\n   */\n  me.destroyAllNow = function(callback) {\n    log(\"force destroying all objects\", 'info');\n    var willDie = availableObjects;\n    availableObjects = [];\n    var obj = willDie.shift();\n    while (obj !== null && obj !== undefined) {\n      me.destroy(obj.obj);\n      obj = willDie.shift();\n    }\n    removeIdleScheduled = false;\n    clearTimeout(removeIdleTimer);\n    if (callback) {\n      callback();\n    }\n  };\n\n  /**\n   * Decorates a function to use a acquired client from the object pool when called.\n   *\n   * @param {Function} decorated\n   *   The decorated function, accepting a client as the first argument and \n   *   (optionally) a callback as the final argument.\n   *\n   * @param {Number} priority\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   */\n  me.pooled = function(decorated, priority) {\n    return function() {\n      var callerArgs = arguments;\n      var callerCallback = callerArgs[callerArgs.length - 1];\n      var callerHasCallback = typeof callerCallback === 'function';\n      me.acquire(function(err, client) {\n        if(err) {\n          if(callerHasCallback) {\n            callerCallback(err);\n          }\n          return;\n        }\n\n        var args = [client].concat(Array.prototype.slice.call(callerArgs, 0, callerHasCallback ? -1 : undefined));\n        args.push(function() {\n          me.release(client);\n          if(callerHasCallback) {\n            callerCallback.apply(null, arguments);\n          }\n        });\n        \n        decorated.apply(null, args);\n      }, priority);\n    };\n  };\n\n  me.getPoolSize = function() {\n    return count;\n  };\n\n  me.getName = function() {\n    return factory.name;\n  };\n\n  me.availableObjectsCount = function() {\n    return availableObjects.length;\n  };\n\n  me.waitingClientsCount = function() {\n    return waitingClients.size();\n  };\n\n\n  // create initial resources (if factory.min > 0)\n  ensureMinimum();\n\n  return me;\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":14305}]],"length":14305}
